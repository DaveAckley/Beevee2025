transient GripInfoMap + DTU + QDebugUtils {
  Self(QDebugUtils& du) { takeDebug(du); }
  
  //// GripInfoMap SERVICES
  constant Unsigned cGRIP_HUNTR = 0u;
  constant Unsigned cGRIP_BV2BY = 1u;
  constant Unsigned cGRIP_NORED = 2u;
  constant Unsigned cGRIP_TRAVL = 3u;
  constant Unsigned cGRIP_TURNW = 4u; //< handled by OrientGrip
  constant Unsigned cGRIP_TURNN = 5u; //< handled by OrientGrip
  constant Unsigned cGRIP_TURNS = 6u; //< handled by OrientGrip
  constant Unsigned cGRIP_TURNE = 7u; //< handled by OrientGrip

  constant Unsigned cMAX_RECAST_SIZE = 4096u;
  typedef BitStorageT(cMAX_RECAST_SIZE) GripInfoBuffer;
  GripInfoBuffer mGripInfoBuffer;

  ClassId getGripInfoClassId(Unsigned gripnum) {
    which (gripnum) {
      case cGRIP_HUNTR: { return HunterGripInfo.classidof; }
      case cGRIP_BV2BY: { return BV2BYGripInfo.classidof; }
      case cGRIP_NORED: { return NoRedGripInfo.classidof; }
      case cGRIP_TRAVL: { return TravelGripInfo.classidof; }
      case cGRIP_TURNW: { return OrientGripInfo.classidof; }
      case cGRIP_TURNN: { return OrientGripInfo.classidof; }
      case cGRIP_TURNS: { return OrientGripInfo.classidof; }
      case cGRIP_TURNE: { return OrientGripInfo.classidof; }
    }
    return 0u;
  }

  GripInfo & getGripInfo(ClassId classid) {
    mD&&pR("GGRINF10")&&pR(classid);
    UrSelf & ur = mGripInfoBuffer.recast(classid,true);
    mD&&pR("GGRINF11")&&pR(ur);
    GripInfo & gripinfo = (GripInfo&) ur;
    mD&&pR("GGRINF12")&&pR(gripinfo);
    return gripinfo;
  }

  Bool isOrientGripNum(Unsigned gripnum) {
    return
      (gripnum >= cGRIP_TURNW) &&
      (gripnum <= cGRIP_TURNE);
  }
}

quark GripInfo + DTU + QDebugUtils + Fail {
  //// GripInfo API
  typedef ClassUtils.ClassId ClassId;
  typedef ClassId SenseDests[4];
  constant ClassId cNULLID = 0u;
  constant SenseDests cSD_NONE = { };

  virtual ARGB getGripColor(Unsigned selector) ;
  virtual String getGripName() ;
  virtual SenseDests getDestinations(ClassId forSensor) ;
  /** modify \c value in place, \return true to ship the signal, false to dump it */
  virtual Bool mapSourceSignalValue(ClassId forSensor, ClassId forDest, ASCII & value) {
    return true;                // default: ship with identity map
  }
  virtual Unsigned getNextGripNumber(Grip& grip) ;

  //// GripInfo SERVICES
  // Do grey processing in all grips?
  constant SenseDests cSD_SFLG = { HFLG.classidof, cNULLID };
  constant SenseDests cSD_SFRG = { HFRG.classidof, cNULLID };
  constant SenseDests cSD_SRLG = { HRLG.classidof, cNULLID };
  constant SenseDests cSD_SRRG = { HRRG.classidof, cNULLID };

  constant SenseDests cSD_IFLG = { HPDF.classidof, HFQA.classidof, cNULLID };
  constant SenseDests cSD_IFRG = { HPDF.classidof, HFQA.classidof, cNULLID };
  constant SenseDests cSD_IRLG = { HPDR.classidof, HFQA.classidof, cNULLID };
  constant SenseDests cSD_IRRG = { HPDR.classidof, HFQA.classidof, cNULLID };
  
  SenseDests getDefaultDestinations(ClassId sensid) {
    which (sensid) {

      // Grey processing in all grips
      case SFLG.classidof: { return cSD_SFLG; }
      case SFRG.classidof: { return cSD_SFRG; }
      case SRLG.classidof: { return cSD_SRLG; }
      case SRRG.classidof: { return cSD_SRRG; }

      case IFLG.classidof: { return cSD_IFLG; }
      case IFRG.classidof: { return cSD_IFRG; }
      case IRLG.classidof: { return cSD_IRLG; }
      case IRRG.classidof: { return cSD_IRRG; }
        
    }
    return cSD_NONE;
  }

}

@Concrete
quark BV2BYGripInfo : GripInfo { // BV2B on Yellow
  constant SenseDests cSD_SLFY = { MRRF.classidof, GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFY = { MLRF.classidof, GRIP.classidof, cNULLID };
  constant SenseDests cSD_SLFR = { GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFR = { GRIP.classidof, cNULLID };

  constant SenseDests cSD_SLLY = { MLEY.classidof, cNULLID };
  constant SenseDests cSD_SLRY = { MLEY.classidof, cNULLID };
  constant SenseDests cSD_SRLY = { MREY.classidof, cNULLID };
  constant SenseDests cSD_SRRY = { MREY.classidof, cNULLID };

  @Override ARGB getGripColor(Unsigned selector) {
    ColorUtils cu;
    return cu.color(0xffffff00);
  }

  @Override String getGripName() { return "BV2BY"; }
  @Override SenseDests getDestinations(ClassId sensid) {
    which (sensid) {
      case SLFY.classidof: { return cSD_SLFY; }
      case SRFY.classidof: { return cSD_SRFY; }
      case SLFR.classidof: { return cSD_SLFR; }
      case SRFR.classidof: { return cSD_SRFR; }

      case SLLY.classidof: { return cSD_SLLY; }
      case SLRY.classidof: { return cSD_SLRY; }
      case SRLY.classidof: { return cSD_SRLY; }
      case SRRY.classidof: { return cSD_SRRY; }
    }
    return getDefaultDestinations(sensid);
  }

  @Override
  virtual Bool mapSourceSignalValue(ClassId forSensor, ClassId forDest, ASCII & raw) {
    if (forDest != GRIP.classidof) {
      if (forSensor == SLFY.classidof || forSensor == SRFY.classidof) {
        if (raw > 0u && raw < 5u) raw = (ASCII) (raw*raw + 4u);     // 1..4     -> 5..20
        else if (raw >= 5u && raw < 16u) raw = (ASCII) (raw + 20u); // 5..15    -> 25..35
        else if (raw >= 16u) raw = (ASCII) (raw/2u + 30u);          // 16..130..250  -> 38..95..155
        raw = (ASCII) (raw/2u);            // XXX HACK GAH TONE ALL DOWN SINCE FAST WHEELS JUST SKID 19..47..77
        raw = intToSignedAscii((Int) raw); // map to signed motor vals
      } else if (forSensor == SLLY.classidof || forSensor == SRRY.classidof) {
        raw = intToSignedAscii(0);                           // return to rest
      } else if (forSensor == SLRY.classidof || forSensor == SRLY.classidof) { 
        raw = intToSignedAscii(-0); // return to rest
      }
    }
    return true;
  }

  @Override
  virtual Unsigned getNextGripNumber(Grip& g) {
    if (g as GRIP) {
      if (g.getFixMaxRed() > 15u) return GripInfoMap.cGRIP_NORED;
      if (g.getFixMaxYellow() < 1u) return GripInfoMap.cGRIP_HUNTR;
    }
    return g.getGripNumber();
  }
}

@Concrete
quark NoRedGripInfo : GripInfo { // avoid red
  constant SenseDests cSD_SLFY = { GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFY = { GRIP.classidof, cNULLID };
  constant SenseDests cSD_SLFR = { MRRF.classidof, GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFR = { MLRF.classidof, GRIP.classidof, cNULLID };

  constant SenseDests cSD_SLLR = { MLEY.classidof, cNULLID };
  constant SenseDests cSD_SRRR = { MREY.classidof, cNULLID };

  @Override ARGB getGripColor(Unsigned selector) {
    ColorUtils cu;
    return cu.color(0xffff0000);
  }

  @Override String getGripName() { return "NORED"; }
  @Override SenseDests getDestinations(ClassId sensid) {
    Random random;
    which (sensid) {
      case SLFY.classidof: { return cSD_SLFY; }
      case SRFY.classidof: { return cSD_SRFY; }
      case SLFR.classidof: { return cSD_SLFR; }
      case SRFR.classidof: { return cSD_SRFR; }

      case SLLR.classidof: { return cSD_SLLR; }
      case SRRR.classidof: { return cSD_SRRR; }
    }
    return getDefaultDestinations(sensid);
  }  

  @Override
  virtual Bool mapSourceSignalValue(ClassId forSensor, ClassId forDest, ASCII & rawvalue) {
    if (forDest == MLEY.classidof || forDest == MREY.classidof) {
      if (forSensor == SLLR.classidof || forSensor == SRRR.classidof) {
        if (rawvalue > 0u) {
          Int cooked = ((Int) rawvalue)*10; // XXX MAGIC NUMBER
          if (cooked > 90) cooked = 90;     // XXX MORE MAGIC NUMBER
          rawvalue = intToSignedAscii(cooked); 
          return true;
        }
      }
    }

    if ((forSensor == SLFR.classidof || forSensor == SRFR.classidof) &&
        (forDest == MLRF.classidof || forDest == MRRF.classidof)) {
      /*
      Int cooked = ((Int) rawvalue)/5;
      if (cooked > 12) cooked = 12;
      rawvalue = intToSignedAscii(-cooked); // back away faster on the less red side
      */
      Int cooked;
      if (rawvalue < 2u) cooked = 2*((Int) rawvalue);  // 0..1 -> 0..2
      else if (rawvalue < 4u) cooked = 1+((Int) rawvalue); // 2..3 -> 3..4
      else if (rawvalue < 8u) cooked = 3+((Int) rawvalue)/2; // 4..7 -> 5..8
      else cooked = 7+((Int) rawvalue)/4;                    // 8..100 -> 9..32
      if (cooked > 14) cooked = 14;
      rawvalue = intToSignedAscii(-cooked); // back away faster on the less red side
    }
    return true;            // default identity map
  }

  @Override
  virtual Unsigned getNextGripNumber(Grip& g) {
    if (g as GRIP) {
      if (g.getFixMaxRed() == 0u) {
        if (g.getFixMaxYellow() > 2u) return GripInfoMap.cGRIP_BV2BY;
        else return GripInfoMap.cGRIP_HUNTR;
      }
    }
    return g.getGripNumber();
  }
}

@Concrete
quark HunterGripInfo : GripInfo { // seek Y
  constant SenseDests cSD_TOCK = { MRRF.classidof, MLRF.classidof, cNULLID };
  constant SenseDests cSD_SLFY = { MRRF.classidof, GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFY = { MLRF.classidof, GRIP.classidof, cNULLID };
  constant SenseDests cSD_SLFR = { GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFR = { GRIP.classidof, cNULLID };
  constant SenseDests cSD_SLLY = { MLEY.classidof, cNULLID };
  constant SenseDests cSD_SLRY = { MLEY.classidof, cNULLID };
  constant SenseDests cSD_SRLY = { MREY.classidof, cNULLID };
  constant SenseDests cSD_SRRY = { MREY.classidof, cNULLID };

  @Override ARGB getGripColor(Unsigned selector) {
    ColorUtils cu;
    return cu.color(0xff0000ff);
  }

  @Override
  virtual Bool mapSourceSignalValue(ClassId forSensor, ClassId forDest, ASCII & rawvalue) {
    /*
    if ((forDest == GRIP.classidof) &&
        (false
         || forSensor == SLFR.classidof
         || forSensor == SLFY.classidof
         || forSensor == SLLR.classidof
         || forSensor == SLLY.classidof
         || forSensor == SLRR.classidof
         || forSensor == SLRY.classidof
         || forSensor == SRFR.classidof
         || forSensor == SRFY.classidof
         || forSensor == SRLR.classidof
         || forSensor == SRLY.classidof
         || forSensor == SRRR.classidof
         || forSensor == SRRY.classidof
         ) &&
        (rawvalue == 255u)) {
      return false;             // dump weird color 255's? could this be a bigger hack?
    }
    if ((forDest == GRIP.classidof) &&
        (false
         || forSensor == SLFR.classidof
         || forSensor == SLFY.classidof
         || forSensor == SLLR.classidof
         || forSensor == SLLY.classidof
         || forSensor == SLRR.classidof
         || forSensor == SLRY.classidof
         || forSensor == SRFR.classidof
         || forSensor == SRFY.classidof
         || forSensor == SRLR.classidof
         || forSensor == SRLY.classidof
         || forSensor == SRRR.classidof
         || forSensor == SRRY.classidof
         )) {
      rawvalue = intToASCII((Int) rawvalue); // sensors come as 0..255
      return true;
    }
    */

    if ((rawvalue > 0u) && (rawvalue < 10u) &&
        (forSensor == SLFY.classidof || forSensor == SRFY.classidof))
      rawvalue = 10u;           // amplify small yellows (for all dests) when hunting?

    if (forDest == MLRF.classidof || forDest == MRRF.classidof) {
      if (forSensor == SLFY.classidof || forSensor == SRFY.classidof) {
        if (rawvalue == 0u) return false; // don't ship 0s when hunting
        rawvalue = intToSignedAscii((Int) rawvalue); 
      } /*else if (forSensor == TOCK.classidof) {
        // Here, rawvalue is the result of TOCK.getSig()
        TOCK tock;              // dummy tock to call on
        rawvalue = tock.switchSigVal(self, rawvalue,forDest);
        }*/
      /*
      else if (forSensor == SLLY.classidof || forSensor == SRRY.classidof) { // heavy outside yellow
        rawvalue = intToSignedAscii((Int) rawvalue);                           // signal turn outward
      } else if (forSensor == SLRY.classidof || forSensor == SRLY.classidof) { // heavy inside yellow
        rawvalue = intToSignedAscii(-(Int) rawvalue);                          // signal turn inward
        }*/
    }
    return true;
  }

  @Override String getGripName() { return "HUNTR"; }
  @Override SenseDests getDestinations(ClassId sensid) {
    Self makeme;
    which (sensid) {
      case TOCK.classidof: { return cSD_TOCK; }
      case SLFY.classidof: { return cSD_SLFY; }
      case SRFY.classidof: { return cSD_SRFY; }
      case SLFR.classidof: { return cSD_SLFR; }
      case SRFR.classidof: { return cSD_SRFR; }
      case SLLY.classidof: { return cSD_SLLY; }
      case SLRY.classidof: { return cSD_SLRY; }
      case SRLY.classidof: { return cSD_SRLY; }
      case SRRY.classidof: { return cSD_SRRY; }

    }
    return getDefaultDestinations(sensid);
  }  
  @Override
  virtual Unsigned getNextGripNumber(Grip& g) {
    if (g as GRIP) {
      if (g.getFixMaxRed() > 3u) return GripInfoMap.cGRIP_NORED;
      if (g.getFixMaxYellow() > 4u) return GripInfoMap.cGRIP_BV2BY;
    }
    return g.getGripNumber();
  }
}

@Concrete
quark TravelGripInfo : GripInfo { // Grid aligned movement
  constant SenseDests cSD_TOCK = { MRRF.classidof, MLRF.classidof, cNULLID };
  constant SenseDests cSD_SLFY = { MRRF.classidof, GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFY = { MLRF.classidof, GRIP.classidof, cNULLID };
  constant SenseDests cSD_SLFR = { GRIP.classidof, cNULLID };
  constant SenseDests cSD_SRFR = { GRIP.classidof, cNULLID };
  constant SenseDests cSD_SLLY = { MLEY.classidof, cNULLID };
  constant SenseDests cSD_SLRY = { MLEY.classidof, cNULLID };
  constant SenseDests cSD_SRLY = { MREY.classidof, cNULLID };
  constant SenseDests cSD_SRRY = { MREY.classidof, cNULLID };

  @Override ARGB getGripColor(Unsigned selector) {
    ColorUtils cu;
    return cu.color(0xff0080ff);
  }

  @Override
  virtual Bool mapSourceSignalValue(ClassId forSensor, ClassId forDest, ASCII & rawvalue) {
    fail(__FILE__,__LINE__); // XXX CONTINUE HERE 
    if ((rawvalue > 0u) && (rawvalue < 10u) &&
        (forSensor == SLFY.classidof || forSensor == SRFY.classidof))
      rawvalue = 10u;           // amplify small yellows (for all dests) when hunting?

    if (forDest == MLRF.classidof || forDest == MRRF.classidof) {
      if (forSensor == SLFY.classidof || forSensor == SRFY.classidof) {
        if (rawvalue == 0u) return false; // don't ship 0s when hunting
        rawvalue = intToSignedAscii((Int) rawvalue); 
      } else if (forSensor == TOCK.classidof) {
        // Here, rawvalue is the result of TOCK.getSig()
        TOCK tock;              // dummy tock to call on
        rawvalue = tock.switchSigVal(self, rawvalue,forDest);
      } else if (forSensor == SLLY.classidof || forSensor == SRRY.classidof) { // heavy outside yellow
        rawvalue = intToSignedAscii((Int) rawvalue);                           // signal turn outward
      } else if (forSensor == SLRY.classidof || forSensor == SRLY.classidof) { // heavy inside yellow
        rawvalue = intToSignedAscii(-(Int) rawvalue);                          // signal turn inward
      }
    }
    return true;
  }

  @Override String getGripName() { return "TRAVL"; }
  @Override SenseDests getDestinations(ClassId sensid) {
    fail(__FILE__,__LINE__); // XXX CONTINUE HERE 
    which (sensid) {
      case TOCK.classidof: { return cSD_TOCK; }
      case SLFY.classidof: { return cSD_SLFY; }
      case SRFY.classidof: { return cSD_SRFY; }
      case SLFR.classidof: { return cSD_SLFR; }
      case SRFR.classidof: { return cSD_SRFR; }
      case SLLY.classidof: { return cSD_SLLY; }
      case SLRY.classidof: { return cSD_SLRY; }
      case SRLY.classidof: { return cSD_SRLY; }
      case SRRY.classidof: { return cSD_SRRY; }
    }
    return getDefaultDestinations(sensid);
  }  
  @Override
  virtual Unsigned getNextGripNumber(Grip& g) {
    fail(__FILE__,__LINE__); // XXX CONTINUE HERE     
    //    if (g.getFixMaxRed() > 3u) return GripInfoMap.cGRIP_NORED;
    //    if (g.getFixMaxYellow() > 1u) return GripInfoMap.cGRIP_BV2BY; 
    return g.getGripNumber();
  }
}


