// RUNNING /data/ackley/PART4/code/D/Beevee2025/scripts/./makeBeeveeSources.py 
// ON ../code/BeeveeBIM.dtoml 
// AND /data/ackley/PART4/code/D/PyBulletTime/cfg/sm225.dtoml ---
//AUTOGENERATED ON 2024-12-28 13:48:12.426564 DO NOT EDIT

@Concrete
transient BeeveeBIM : BrainInfoMap {
  constant ClassId cXBClassIds[] = {
    XBInfo_HOTBOX.classidof,
    XBInfo_GREEN.classidof,
    XBInfo_GREYS.classidof,
    XBInfo_CTLGREY.classidof,
    0 // unused, illegal
  }; // cXBClassIds

  constant ClassId cTAPClassIds[] = {
    BVPITCH.classidof,  //< 0 sensor Beevee Pitch
    BVROLL.classidof,  //< 1 sensor Beevee Roll
    SFLG.classidof,  //< 2 sensor Front Left Floor Grey Sensor
    SFRG.classidof,  //< 3 sensor Front Right Floor Grey Sensor
    SRLG.classidof,  //< 4 sensor Rear Left Floor Grey Sensor
    SRRG.classidof,  //< 5 sensor Rear Right Floor Grey Sensor
    SLFR.classidof,  //< 6 sensor Left Front Red Detector
    SLLR.classidof,  //< 7 sensor Left Left-side Red Detector
    SLRR.classidof,  //< 8 sensor Left Right-side Red Detector
    SLFG.classidof,  //< 9 sensor Left Front Green Detector
    SLFY.classidof,  //< 10 sensor Left Front Yellow Detector
    SLLY.classidof,  //< 11 sensor Left Left-side Yellow Detector
    SLRY.classidof,  //< 12 sensor Left Right-side Yellow Detector
    SRFR.classidof,  //< 13 sensor Right Front Red Detector
    SRLR.classidof,  //< 14 sensor Right Left-side Red Detector
    SRRR.classidof,  //< 15 sensor Right Right-side Red Detector
    SRFG.classidof,  //< 16 sensor Right Front Green Detector
    SRFY.classidof,  //< 17 sensor Right Front Yellow Detector
    SRLY.classidof,  //< 18 sensor Right Left-side Yellow Detector
    SRRY.classidof,  //< 19 sensor Right Right-side Yellow Detector
    SDBG10.classidof,  //< 20 sensor Debug sensor 10
    TOCK.classidof,  //< 21 sensor TOCK
    IFLG.classidof,  //< 22 sensor IFLG
    IFRG.classidof,  //< 23 sensor IFRG
    IRRG.classidof,  //< 24 sensor IRRG
    IRLG.classidof,  //< 25 sensor IRLG
    MRRF.classidof,  //< 26 motor Right Rear Motor Forward
    MLRF.classidof,  //< 27 motor Left Rear Motor Forward
    GRIP.classidof,  //< 28 motor Dummy Motor for Internal Grip
    MLEY.classidof,  //< 29 motor Left Eyestalk Angle
    MREY.classidof,  //< 30 motor Right Eyestalk Angle
    MDBG10.classidof,  //< 31 motor Debug motor 10
    GREG.classidof,  //< 32 hidden GREG
    HFLG.classidof,  //< 33 hidden HFLG
    HFRG.classidof,  //< 34 hidden HFRG
    HRRG.classidof,  //< 35 hidden HRRG
    HRLG.classidof,  //< 36 hidden HRLG
    HFQA.classidof,  //< 37 hidden HFQA
    HPDF.classidof,  //< 38 hidden HPDF
    HPDR.classidof,  //< 39 hidden HPDR
  }; // cTAPClassIds

  constant String cTAPNames[] = {
    "BVPITCH",  //< 0 sensor Beevee Pitch
    "BVROLL",  //< 1 sensor Beevee Roll
    "SFLG",  //< 2 sensor Front Left Floor Grey Sensor
    "SFRG",  //< 3 sensor Front Right Floor Grey Sensor
    "SRLG",  //< 4 sensor Rear Left Floor Grey Sensor
    "SRRG",  //< 5 sensor Rear Right Floor Grey Sensor
    "SLFR",  //< 6 sensor Left Front Red Detector
    "SLLR",  //< 7 sensor Left Left-side Red Detector
    "SLRR",  //< 8 sensor Left Right-side Red Detector
    "SLFG",  //< 9 sensor Left Front Green Detector
    "SLFY",  //< 10 sensor Left Front Yellow Detector
    "SLLY",  //< 11 sensor Left Left-side Yellow Detector
    "SLRY",  //< 12 sensor Left Right-side Yellow Detector
    "SRFR",  //< 13 sensor Right Front Red Detector
    "SRLR",  //< 14 sensor Right Left-side Red Detector
    "SRRR",  //< 15 sensor Right Right-side Red Detector
    "SRFG",  //< 16 sensor Right Front Green Detector
    "SRFY",  //< 17 sensor Right Front Yellow Detector
    "SRLY",  //< 18 sensor Right Left-side Yellow Detector
    "SRRY",  //< 19 sensor Right Right-side Yellow Detector
    "SDBG10",  //< 20 sensor Debug sensor 10
    "TOCK",  //< 21 sensor TOCK
    "IFLG",  //< 22 sensor IFLG
    "IFRG",  //< 23 sensor IFRG
    "IRRG",  //< 24 sensor IRRG
    "IRLG",  //< 25 sensor IRLG
    "MRRF",  //< 26 motor Right Rear Motor Forward
    "MLRF",  //< 27 motor Left Rear Motor Forward
    "GRIP",  //< 28 motor Dummy Motor for Internal Grip
    "MLEY",  //< 29 motor Left Eyestalk Angle
    "MREY",  //< 30 motor Right Eyestalk Angle
    "MDBG10",  //< 31 motor Debug motor 10
    "GREG",  //< 32 hidden GREG
    "HFLG",  //< 33 hidden HFLG
    "HFRG",  //< 34 hidden HFRG
    "HRRG",  //< 35 hidden HRRG
    "HRLG",  //< 36 hidden HRLG
    "HFQA",  //< 37 hidden HFQA
    "HPDF",  //< 38 hidden HPDF
    "HPDR",  //< 39 hidden HPDR
  }; // cTAPNames

  //// BrainInfoMap API
  @Override
  Unsigned getXBCount() { return cXBClassIds.lengthof - 1u; }
  @Override
  Unsigned getContainingXBIndex(C2D absc) {
    { C2D s(XBInfo_HOTBOX.cXBI_SIZ), p(XBInfo_HOTBOX.cXBI_POS);
       if (s.contains(absc-p)) return 0u; }
    { C2D s(XBInfo_GREEN.cXBI_SIZ), p(XBInfo_GREEN.cXBI_POS);
       if (s.contains(absc-p)) return 1u; }
    { C2D s(XBInfo_GREYS.cXBI_SIZ), p(XBInfo_GREYS.cXBI_POS);
       if (s.contains(absc-p)) return 2u; }
    { C2D s(XBInfo_CTLGREY.cXBI_SIZ), p(XBInfo_CTLGREY.cXBI_POS);
       if (s.contains(absc-p)) return 3u; }
    return Unsigned.maxof;
  }

  @Override
  XBInfo & getXBInfo(Unsigned idx, XBInfoBuffer xbib) {
    Unsigned cnt = getXBCount();
    if (idx >= cnt) fail(__FILE__,__LINE__);
    ClassId cid = cXBClassIds[idx];
    ClassUtils cu;
    if (!cu.isBase(cid, XBInfo.classidof)) 
      fail(__FILE__,__LINE__);
    XBInfo & ret = (XBInfo&) xbib.recast(cid,true);
    return ret;
  }

  @Override
  virtual ClassId getTAPClassIdFromTapIdx(Unsigned tapidx) {
    return cTAPClassIds[tapidx]; // or fail if tapidx >= cTAPClassIds.lengthof
  }

  @Override
  virtual Unsigned getTAPCount() {
    return cTAPClassIds.lengthof;
  }

  @Override
  virtual Unsigned getTapIdxFromClassId(ClassId cid) {
    for (Unsigned i = 0u; i < cTAPClassIds.lengthof; ++i) {
      if (cid == cTAPClassIds[i])
        return i;
    }
    return Unsigned.maxof;
  }

  @Override
  virtual String getTAPNameFromTapIdx(Unsigned tapidx) {
    String ret;  // null by default
    if (tapidx < cTAPNames.lengthof) ret = cTAPNames[tapidx];
    return ret;
  }


}
// {'uses': {'HOTBOX': ['in', (-4, -1), 1]}} TAP in SRFR #1 in HOTBOX at (-4, -1)
// {'uses': {'HOTBOX': ['in', (-3, -1), 2]}} TAP in SRFY #2 in HOTBOX at (-3, -1)
// {'uses': {'HOTBOX': ['in', (-2, -1), 3]}} TAP in SLFR #3 in HOTBOX at (-2, -1)
// {'uses': {'HOTBOX': ['in', (-1, -1), 4]}} TAP in SLFY #4 in HOTBOX at (-1, -1)
// {'uses': {'HOTBOX': ['in', (0, -1), 5]}} TAP in TOCK #5 in HOTBOX at (0, -1)
// {'uses': {'HOTBOX': ['in', (1, -1), 6]}} TAP in SLRY #6 in HOTBOX at (1, -1)
// {'uses': {'HOTBOX': ['in', (2, -1), 7]}} TAP in SLLY #7 in HOTBOX at (2, -1)
// {'uses': {'HOTBOX': ['in', (3, -1), 8]}} TAP in SRRY #8 in HOTBOX at (3, -1)
// {'uses': {'HOTBOX': ['in', (4, -1), 9]}} TAP in SRLY #9 in HOTBOX at (4, -1)
// {'uses': {'HOTBOX': ['in', (5, -1), 10]}} TAP in SRRR #10 in HOTBOX at (5, -1)
// {'uses': {'HOTBOX': ['in', (6, -1), 11]}} TAP in SLLR #11 in HOTBOX at (6, -1)
// {'uses': {'HOTBOX': ['out', (-5, -2), 1]}} TAP out GRIP #1 in HOTBOX at (-5, -2)
// {'uses': {'HOTBOX': ['out', (-5, -3), 2]}} TAP out MRRF #2 in HOTBOX at (-5, -3)
// {'uses': {'HOTBOX': ['out', (-5, -4), 3]}} TAP out MLRF #3 in HOTBOX at (-5, -4)
// {'uses': {'HOTBOX': ['out', (-5, -5), 4]}} TAP out MREY #4 in HOTBOX at (-5, -5)
// {'uses': {'HOTBOX': ['out', (-5, -6), 5]}} TAP out MLEY #5 in HOTBOX at (-5, -6)
// {'uses': {'GREEN': ['in', (-5, 9), 1]}} TAP in SLFG #1 in GREEN at (-5, 9)
// {'uses': {'GREEN': ['in', (-5, 8), 2]}} TAP in SRFG #2 in GREEN at (-5, 8)
// {'uses': {'GREEN': ['out', (-4, 10), 1]}} TAP out GREG #1 in GREEN at (-4, 10)
// {'uses': {'GREYS': ['in', (-20, -1), 1]}} TAP in SFLG #1 in GREYS at (-20, -1)
// {'uses': {'GREYS': ['in', (-19, -1), 2]}} TAP in SFRG #2 in GREYS at (-19, -1)
// {'uses': {'GREYS': ['in', (-18, -1), 3]}} TAP in SRRG #3 in GREYS at (-18, -1)
// {'uses': {'GREYS': ['in', (-17, -1), 4]}} TAP in SRLG #4 in GREYS at (-17, -1)
// {'uses': {'GREYS': ['out', (-21, 0), 1]}} TAP out HFLG #1 in GREYS at (-21, 0)
// {'uses': {'GREYS': ['out', (-21, 1), 2]}} TAP out HFRG #2 in GREYS at (-21, 1)
// {'uses': {'GREYS': ['out', (-21, 2), 3]}} TAP out HRRG #3 in GREYS at (-21, 2)
// {'uses': {'GREYS': ['out', (-21, 3), 4]}} TAP out HRLG #4 in GREYS at (-21, 3)
// {'uses': {'CTLGREY': ['in', (-14, -3), 1]}} TAP in IFLG #1 in CTLGREY at (-14, -3)
// {'uses': {'CTLGREY': ['in', (-14, -4), 2]}} TAP in IFRG #2 in CTLGREY at (-14, -4)
// {'uses': {'CTLGREY': ['in', (-14, -5), 3]}} TAP in IRRG #3 in CTLGREY at (-14, -5)
// {'uses': {'CTLGREY': ['in', (-14, -6), 4]}} TAP in IRLG #4 in CTLGREY at (-14, -6)
// {'uses': {'CTLGREY': ['out', (-15, -2), 1]}} TAP out HFQA #1 in CTLGREY at (-15, -2)
// {'uses': {'CTLGREY': ['out', (-16, -2), 2]}} TAP out HPDF #2 in CTLGREY at (-16, -2)
// {'uses': {'CTLGREY': ['out', (-17, -2), 3]}} TAP out HPDR #3 in CTLGREY at (-17, -2)

//NAME XBInfo_HOTBOX IS {'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]}
@Concrete
transient XBInfo_HOTBOX : XBInfo {
  constant ClassId cIN_TAPS[] = {
    SRFR.classidof,
    SRFY.classidof,
    SLFR.classidof,
    SLFY.classidof,
    TOCK.classidof,
    SLRY.classidof,
    SLLY.classidof,
    SRRY.classidof,
    SRLY.classidof,
    SRRR.classidof,
    SLLR.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    GRIP.classidof,
    MRRF.classidof,
    MLRF.classidof,
    MREY.classidof,
    MLEY.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_NW;
  constant AxialDir cXBI_IN_DIR = cN;
  constant AxialDir cXBI_OUT_DIR = cW;

  constant C2D cXBI_POS = { .x = -5, .y = -1 };
  constant C2D cXBI_SIZ = { .x = 13, .y = 7 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "HOTBOX"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 0 &&
        relc.x <  12 && relc.y < 1) {
      feedad = cN;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 6) {
      feedad = cW;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]}) ((1, 0), (12, 1))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 1 && relc.y >= 0 &&
        relc.x <  12 && relc.y < 1) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-0));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]}) ((0, 1), (1, 6))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 6) {
      C2D diff((C2D.Coord) (relc.x-0),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_HOTBOX

//NAME XBInfo_GREEN IS {'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]}
@Concrete
transient XBInfo_GREEN : XBInfo {
  constant ClassId cIN_TAPS[] = {
    SLFG.classidof,
    SRFG.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    GREG.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_NW;
  constant AxialDir cXBI_IN_DIR = cW;
  constant AxialDir cXBI_OUT_DIR = cN;

  constant C2D cXBI_POS = { .x = -5, .y = 10 };
  constant C2D cXBI_SIZ = { .x = 3, .y = 4 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "GREEN"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 3) {
      feedad = cW;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 0 &&
        relc.x <  2 && relc.y < 1) {
      feedad = cN;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    if (fromid == GREG.classidof) return (TapIdx) bim.getTapIdxFromClassId(MRRF.classidof);
    if (fromid == GREG.classidof) return (TapIdx) bim.getTapIdxFromClassId(MLRF.classidof);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]}) ((0, 1), (1, 3))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 3) {
      C2D diff((C2D.Coord) (relc.x-0),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]}) ((1, 0), (2, 1))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 1 && relc.y >= 0 &&
        relc.x <  2 && relc.y < 1) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-0));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_GREEN

//NAME XBInfo_GREYS IS {'indir': 'N', 'outdir': 'E', 'pos': [-21, -1], 'inputs': ['SFLG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG']], 'number': 2, 'origin': 'NE', 'inoff': [1, 0], 'outoff': [0, 1], 'size': [6, 6]}
@Concrete
transient XBInfo_GREYS : XBInfo {
  constant ClassId cIN_TAPS[] = {
    SFLG.classidof,
    SFRG.classidof,
    SRRG.classidof,
    SRLG.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    HFLG.classidof,
    HFRG.classidof,
    HRRG.classidof,
    HRLG.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_NE;
  constant AxialDir cXBI_IN_DIR = cN;
  constant AxialDir cXBI_OUT_DIR = cE;

  constant C2D cXBI_POS = { .x = -21, .y = -1 };
  constant C2D cXBI_SIZ = { .x = 6, .y = 6 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "GREYS"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'N', 'outdir': 'E', 'pos': [-21, -1], 'inputs': ['SFLG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG']], 'number': 2, 'origin': 'NE', 'inoff': [1, 0], 'outoff': [0, 1], 'size': [6, 6]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 0 &&
        relc.x <  5 && relc.y < 1) {
      feedad = cN;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 5 && relc.y >= 1 &&
        relc.x <  6 && relc.y < 5) {
      feedad = cE;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'N', 'outdir': 'E', 'pos': [-21, -1], 'inputs': ['SFLG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG']], 'number': 2, 'origin': 'NE', 'inoff': [1, 0], 'outoff': [0, 1], 'size': [6, 6]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    if (fromid == HFLG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IFLG.classidof);
    if (fromid == HFRG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IFRG.classidof);
    if (fromid == HRRG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IRRG.classidof);
    if (fromid == HRLG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IRLG.classidof);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'N', 'outdir': 'E', 'pos': [-21, -1], 'inputs': ['SFLG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG']], 'number': 2, 'origin': 'NE', 'inoff': [1, 0], 'outoff': [0, 1], 'size': [6, 6]}) ((1, 0), (5, 1))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 1 && relc.y >= 0 &&
        relc.x <  5 && relc.y < 1) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-0));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'N', 'outdir': 'E', 'pos': [-21, -1], 'inputs': ['SFLG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG']], 'number': 2, 'origin': 'NE', 'inoff': [1, 0], 'outoff': [0, 1], 'size': [6, 6]}) ((5, 1), (6, 5))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 5 && relc.y >= 1 &&
        relc.x <  6 && relc.y < 5) {
      C2D diff((C2D.Coord) (relc.x-5),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_GREYS

//NAME XBInfo_CTLGREY IS {'indir': 'W', 'outdir': 'S', 'pos': [-14, -2], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SW', 'inoff': [0, -1], 'outoff': [-1, 0], 'size': [5, 6]}
@Concrete
transient XBInfo_CTLGREY : XBInfo {
  constant ClassId cIN_TAPS[] = {
    IFLG.classidof,
    IFRG.classidof,
    IRRG.classidof,
    IRLG.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    HFQA.classidof,
    HPDF.classidof,
    HPDR.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_SW;
  constant AxialDir cXBI_IN_DIR = cW;
  constant AxialDir cXBI_OUT_DIR = cS;

  constant C2D cXBI_POS = { .x = -14, .y = -2 };
  constant C2D cXBI_SIZ = { .x = 5, .y = 6 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "CTLGREY"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'W', 'outdir': 'S', 'pos': [-14, -2], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SW', 'inoff': [0, -1], 'outoff': [-1, 0], 'size': [5, 6]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 5) {
      feedad = cW;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 5 &&
        relc.x <  4 && relc.y < 6) {
      feedad = cS;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'W', 'outdir': 'S', 'pos': [-14, -2], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SW', 'inoff': [0, -1], 'outoff': [-1, 0], 'size': [5, 6]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    if (fromid == HPDF.classidof) return (TapIdx) bim.getTapIdxFromClassId(MLRF.classidof);
    if (fromid == HPDR.classidof) return (TapIdx) bim.getTapIdxFromClassId(MRRF.classidof);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'W', 'outdir': 'S', 'pos': [-14, -2], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SW', 'inoff': [0, -1], 'outoff': [-1, 0], 'size': [5, 6]}) ((0, 1), (1, 5))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 5) {
      C2D diff((C2D.Coord) (relc.x-0),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'W', 'outdir': 'S', 'pos': [-14, -2], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SW', 'inoff': [0, -1], 'outoff': [-1, 0], 'size': [5, 6]}) ((1, 5), (4, 6))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 1 && relc.y >= 5 &&
        relc.x <  4 && relc.y < 6) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-5));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_CTLGREY
