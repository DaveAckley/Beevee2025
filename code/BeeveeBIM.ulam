// RUNNING /data/ackley/PART4/code/D/Beevee2025/scripts/./makeBeeveeSources.py 
// ON ../code/BeeveeBIM.dtoml 
// AND /data/ackley/PART4/code/D/PyBulletTime/cfg/sm227.dtoml ---
//AUTOGENERATED ON 2025-01-30 20:53:20.834340 DO NOT EDIT

@Concrete
transient BeeveeBIM : BrainInfoMap {
  constant ClassId cXBClassIds[] = {
    XBInfo_HOTBOX.classidof,
    XBInfo_GREEN.classidof,
    XBInfo_GREYS.classidof,
    XBInfo_CTLGREY.classidof,
    XBInfo_TILES.classidof,
    0 // unused, illegal
  }; // cXBClassIds

  constant ClassId cTAPClassIds[] = {
    BVPITCH.classidof,  //< 0 sensor Beevee Pitch
    BVROLL.classidof,  //< 1 sensor Beevee Roll
    SFLG.classidof,  //< 2 sensor Front Left Floor Grey Sensor
    SFCG.classidof,  //< 3 sensor Front Center Floor Grey Sensor
    SFRG.classidof,  //< 4 sensor Front Right Floor Grey Sensor
    SRLG.classidof,  //< 5 sensor Rear Left Floor Grey Sensor
    SRRG.classidof,  //< 6 sensor Rear Right Floor Grey Sensor
    SLFR.classidof,  //< 7 sensor Left Front Red Detector
    SLLR.classidof,  //< 8 sensor Left Left-side Red Detector
    SLRR.classidof,  //< 9 sensor Left Right-side Red Detector
    SLFG.classidof,  //< 10 sensor Left Front Green Detector
    SLFY.classidof,  //< 11 sensor Left Front Yellow Detector
    SLLY.classidof,  //< 12 sensor Left Left-side Yellow Detector
    SLRY.classidof,  //< 13 sensor Left Right-side Yellow Detector
    SRFR.classidof,  //< 14 sensor Right Front Red Detector
    SRLR.classidof,  //< 15 sensor Right Left-side Red Detector
    SRRR.classidof,  //< 16 sensor Right Right-side Red Detector
    SRFG.classidof,  //< 17 sensor Right Front Green Detector
    SRFY.classidof,  //< 18 sensor Right Front Yellow Detector
    SRLY.classidof,  //< 19 sensor Right Left-side Yellow Detector
    SRRY.classidof,  //< 20 sensor Right Right-side Yellow Detector
    SDBG10.classidof,  //< 21 sensor Debug sensor 10
    TOCK.classidof,  //< 22 sensor TOCK
    IFLG.classidof,  //< 23 sensor IFLG
    IFRG.classidof,  //< 24 sensor IFRG
    IRRG.classidof,  //< 25 sensor IRRG
    IRLG.classidof,  //< 26 sensor IRLG
    GTCC.classidof,  //< 27 sensor GTCC
    MRRF.classidof,  //< 28 motor Right Rear Motor Forward
    MLRF.classidof,  //< 29 motor Left Rear Motor Forward
    GRIP.classidof,  //< 30 motor Dummy Motor for Internal Grip
    MLEY.classidof,  //< 31 motor Left Eyestalk Angle
    MREY.classidof,  //< 32 motor Right Eyestalk Angle
    MDBG10.classidof,  //< 33 motor Debug motor 10
    GREG.classidof,  //< 34 hidden GREG
    HFLG.classidof,  //< 35 hidden HFLG
    HFRG.classidof,  //< 36 hidden HFRG
    HRRG.classidof,  //< 37 hidden HRRG
    HRLG.classidof,  //< 38 hidden HRLG
    CLOK.classidof,  //< 39 hidden CLOK
    TRAKPD.classidof,  //< 40 hidden TRAKPD
    TRAK.classidof,  //< 41 hidden TRAK
    HFQA.classidof,  //< 42 hidden HFQA
    HPDF.classidof,  //< 43 hidden HPDF
    HPDR.classidof,  //< 44 hidden HPDR
    OCLK.classidof,  //< 45 hidden OCLK
  }; // cTAPClassIds

  constant String cTAPNames[] = {
    "BVPITCH",  //< 0 sensor Beevee Pitch
    "BVROLL",  //< 1 sensor Beevee Roll
    "SFLG",  //< 2 sensor Front Left Floor Grey Sensor
    "SFCG",  //< 3 sensor Front Center Floor Grey Sensor
    "SFRG",  //< 4 sensor Front Right Floor Grey Sensor
    "SRLG",  //< 5 sensor Rear Left Floor Grey Sensor
    "SRRG",  //< 6 sensor Rear Right Floor Grey Sensor
    "SLFR",  //< 7 sensor Left Front Red Detector
    "SLLR",  //< 8 sensor Left Left-side Red Detector
    "SLRR",  //< 9 sensor Left Right-side Red Detector
    "SLFG",  //< 10 sensor Left Front Green Detector
    "SLFY",  //< 11 sensor Left Front Yellow Detector
    "SLLY",  //< 12 sensor Left Left-side Yellow Detector
    "SLRY",  //< 13 sensor Left Right-side Yellow Detector
    "SRFR",  //< 14 sensor Right Front Red Detector
    "SRLR",  //< 15 sensor Right Left-side Red Detector
    "SRRR",  //< 16 sensor Right Right-side Red Detector
    "SRFG",  //< 17 sensor Right Front Green Detector
    "SRFY",  //< 18 sensor Right Front Yellow Detector
    "SRLY",  //< 19 sensor Right Left-side Yellow Detector
    "SRRY",  //< 20 sensor Right Right-side Yellow Detector
    "SDBG10",  //< 21 sensor Debug sensor 10
    "TOCK",  //< 22 sensor TOCK
    "IFLG",  //< 23 sensor IFLG
    "IFRG",  //< 24 sensor IFRG
    "IRRG",  //< 25 sensor IRRG
    "IRLG",  //< 26 sensor IRLG
    "GTCC",  //< 27 sensor GTCC
    "MRRF",  //< 28 motor Right Rear Motor Forward
    "MLRF",  //< 29 motor Left Rear Motor Forward
    "GRIP",  //< 30 motor Dummy Motor for Internal Grip
    "MLEY",  //< 31 motor Left Eyestalk Angle
    "MREY",  //< 32 motor Right Eyestalk Angle
    "MDBG10",  //< 33 motor Debug motor 10
    "GREG",  //< 34 hidden GREG
    "HFLG",  //< 35 hidden HFLG
    "HFRG",  //< 36 hidden HFRG
    "HRRG",  //< 37 hidden HRRG
    "HRLG",  //< 38 hidden HRLG
    "CLOK",  //< 39 hidden CLOK
    "TRAKPD",  //< 40 hidden TRAKPD
    "TRAK",  //< 41 hidden TRAK
    "HFQA",  //< 42 hidden HFQA
    "HPDF",  //< 43 hidden HPDF
    "HPDR",  //< 44 hidden HPDR
    "OCLK",  //< 45 hidden OCLK
  }; // cTAPNames

  //// BrainInfoMap API
  @Override
  Unsigned getXBCount() { return cXBClassIds.lengthof - 1u; }
  @Override
  Unsigned getContainingXBIndex(C2D absc) {
    { C2D s(XBInfo_HOTBOX.cXBI_SIZ), p(XBInfo_HOTBOX.cXBI_POS);
       if (s.contains(absc-p)) return 0u; }
    { C2D s(XBInfo_GREEN.cXBI_SIZ), p(XBInfo_GREEN.cXBI_POS);
       if (s.contains(absc-p)) return 1u; }
    { C2D s(XBInfo_GREYS.cXBI_SIZ), p(XBInfo_GREYS.cXBI_POS);
       if (s.contains(absc-p)) return 2u; }
    { C2D s(XBInfo_CTLGREY.cXBI_SIZ), p(XBInfo_CTLGREY.cXBI_POS);
       if (s.contains(absc-p)) return 3u; }
    { C2D s(XBInfo_TILES.cXBI_SIZ), p(XBInfo_TILES.cXBI_POS);
       if (s.contains(absc-p)) return 4u; }
    return Unsigned.maxof;
  }

  @Override
  XBInfo & getXBInfo(Unsigned idx, XBInfoBuffer xbib) {
    Unsigned cnt = getXBCount();
    if (idx >= cnt) fail(__FILE__,__LINE__);
    ClassId cid = cXBClassIds[idx];
    ClassUtils cu;
    if (!cu.isBase(cid, XBInfo.classidof)) 
      fail(__FILE__,__LINE__);
    XBInfo & ret = (XBInfo&) xbib.recast(cid,true);
    return ret;
  }

  @Override
  virtual ClassId getTAPClassIdFromTapIdx(Unsigned tapidx) {
    return cTAPClassIds[tapidx]; // or fail if tapidx >= cTAPClassIds.lengthof
  }

  @Override
  virtual Unsigned getTAPCount() {
    return cTAPClassIds.lengthof;
  }

  @Override
  virtual Unsigned getTapIdxFromClassId(ClassId cid) {
    for (Unsigned i = 0u; i < cTAPClassIds.lengthof; ++i) {
      if (cid == cTAPClassIds[i])
        return i;
    }
    return Unsigned.maxof;
  }

  @Override
  virtual String getTAPNameFromTapIdx(Unsigned tapidx) {
    String ret;  // null by default
    if (tapidx < cTAPNames.lengthof) ret = cTAPNames[tapidx];
    return ret;
  }


}
// {'uses': {'HOTBOX': ['in', (-4, -1), 1]}} TAP in SRFR #1 in HOTBOX at (-4, -1)
// {'uses': {'HOTBOX': ['in', (-3, -1), 2]}} TAP in SRFY #2 in HOTBOX at (-3, -1)
// {'uses': {'HOTBOX': ['in', (-2, -1), 3]}} TAP in SLFR #3 in HOTBOX at (-2, -1)
// {'uses': {'HOTBOX': ['in', (-1, -1), 4]}} TAP in SLFY #4 in HOTBOX at (-1, -1)
// {'uses': {'HOTBOX': ['in', (0, -1), 5]}} TAP in TOCK #5 in HOTBOX at (0, -1)
// {'uses': {'HOTBOX': ['in', (1, -1), 6]}} TAP in SLRY #6 in HOTBOX at (1, -1)
// {'uses': {'HOTBOX': ['in', (2, -1), 7]}} TAP in SLLY #7 in HOTBOX at (2, -1)
// {'uses': {'HOTBOX': ['in', (3, -1), 8]}} TAP in SRRY #8 in HOTBOX at (3, -1)
// {'uses': {'HOTBOX': ['in', (4, -1), 9]}} TAP in SRLY #9 in HOTBOX at (4, -1)
// {'uses': {'HOTBOX': ['in', (5, -1), 10]}} TAP in SRRR #10 in HOTBOX at (5, -1)
// {'uses': {'HOTBOX': ['in', (6, -1), 11]}} TAP in SLLR #11 in HOTBOX at (6, -1)
// {'uses': {'HOTBOX': ['out', (-5, -2), 1]}} TAP out GRIP #1 in HOTBOX at (-5, -2)
// {'uses': {'HOTBOX': ['out', (-5, -3), 2]}} TAP out MRRF #2 in HOTBOX at (-5, -3)
// {'uses': {'HOTBOX': ['out', (-5, -4), 3]}} TAP out MLRF #3 in HOTBOX at (-5, -4)
// {'uses': {'HOTBOX': ['out', (-5, -5), 4]}} TAP out MREY #4 in HOTBOX at (-5, -5)
// {'uses': {'HOTBOX': ['out', (-5, -6), 5]}} TAP out MLEY #5 in HOTBOX at (-5, -6)
// {'uses': {'GREEN': ['in', (-5, 9), 1]}} TAP in SLFG #1 in GREEN at (-5, 9)
// {'uses': {'GREEN': ['in', (-5, 8), 2]}} TAP in SRFG #2 in GREEN at (-5, 8)
// {'uses': {'GREEN': ['out', (-4, 10), 1]}} TAP out GREG #1 in GREEN at (-4, 10)
// {'uses': {'GREYS': ['in', (-18, 0), 1]}} TAP in SFLG #1 in GREYS at (-18, 0)
// {'uses': {'GREYS': ['in', (-18, 1), 2]}} TAP in SFCG #2 in GREYS at (-18, 1)
// {'uses': {'GREYS': ['in', (-18, 2), 3]}} TAP in SFRG #3 in GREYS at (-18, 2)
// {'uses': {'GREYS': ['in', (-18, 3), 4]}} TAP in SRRG #4 in GREYS at (-18, 3)
// {'uses': {'GREYS': ['in', (-18, 4), 5]}} TAP in SRLG #5 in GREYS at (-18, 4)
// {'uses': {'GREYS': ['out', (-17, -1), 1]}} TAP out HFLG #1 in GREYS at (-17, -1)
// {'uses': {'GREYS': ['out', (-16, -1), 2]}} TAP out HFRG #2 in GREYS at (-16, -1)
// {'uses': {'GREYS': ['out', (-15, -1), 3]}} TAP out HRRG #3 in GREYS at (-15, -1)
// {'uses': {'GREYS': ['out', (-14, -1), 4]}} TAP out HRLG #4 in GREYS at (-14, -1)
// {'uses': {'GREYS': ['out', (-13, -1), 5]}} TAP out CLOK #5 in GREYS at (-13, -1)
// {'uses': {'GREYS': ['out', (-12, -1), 6]}} TAP out TRAKPD #6 in GREYS at (-12, -1)
// {'uses': {'GREYS': ['out', (-11, -1), 7]}} TAP out TRAK #7 in GREYS at (-11, -1)
// {'uses': {'CTLGREY': ['in', (-9, -11), 1]}} TAP in IFLG #1 in CTLGREY at (-9, -11)
// {'uses': {'CTLGREY': ['in', (-10, -11), 2]}} TAP in IFRG #2 in CTLGREY at (-10, -11)
// {'uses': {'CTLGREY': ['in', (-11, -11), 3]}} TAP in IRRG #3 in CTLGREY at (-11, -11)
// {'uses': {'CTLGREY': ['in', (-12, -11), 4]}} TAP in IRLG #4 in CTLGREY at (-12, -11)
// {'uses': {'CTLGREY': ['out', (-8, -10), 1]}} TAP out HFQA #1 in CTLGREY at (-8, -10)
// {'uses': {'CTLGREY': ['out', (-8, -9), 2]}} TAP out HPDF #2 in CTLGREY at (-8, -9)
// {'uses': {'CTLGREY': ['out', (-8, -8), 3]}} TAP out HPDR #3 in CTLGREY at (-8, -8)
// {'uses': {'TILES': ['in', (-14, -10), 1]}} TAP in GTCC #1 in TILES at (-14, -10)
// {'uses': {'TILES': ['out', (-13, -11), 1]}} TAP out OCLK #1 in TILES at (-13, -11)

//NAME XBInfo_HOTBOX IS {'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]}
@Concrete
transient XBInfo_HOTBOX : XBInfo {
  constant ClassId cIN_TAPS[] = {
    SRFR.classidof,
    SRFY.classidof,
    SLFR.classidof,
    SLFY.classidof,
    TOCK.classidof,
    SLRY.classidof,
    SLLY.classidof,
    SRRY.classidof,
    SRLY.classidof,
    SRRR.classidof,
    SLLR.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    GRIP.classidof,
    MRRF.classidof,
    MLRF.classidof,
    MREY.classidof,
    MLEY.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_NW;
  constant AxialDir cXBI_IN_DIR = cN;
  constant AxialDir cXBI_OUT_DIR = cW;

  constant C2D cXBI_POS = { .x = -5, .y = -1 };
  constant C2D cXBI_SIZ = { .x = 13, .y = 7 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "HOTBOX"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 0 &&
        relc.x <  12 && relc.y < 1) {
      feedad = cN;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 6) {
      feedad = cW;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]}) ((1, 0), (12, 1))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 1 && relc.y >= 0 &&
        relc.x <  12 && relc.y < 1) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-0));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'N', 'outdir': 'W', 'pos': [-5, -1], 'inputs': ['SRFR', 'SRFY', 'SLFR', 'SLFY', 'TOCK', 'SLRY', 'SLLY', 'SRRY', 'SRLY', 'SRRR', 'SLLR'], 'outputs': ['GRIP', 'MRRF', 'MLRF', 'MREY', 'MLEY'], 'number': 0, 'origin': 'NW', 'inoff': [1, 0], 'outoff': [0, -1], 'size': [13, 7]}) ((0, 1), (1, 6))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 6) {
      C2D diff((C2D.Coord) (relc.x-0),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_HOTBOX

//NAME XBInfo_GREEN IS {'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]}
@Concrete
transient XBInfo_GREEN : XBInfo {
  constant ClassId cIN_TAPS[] = {
    SLFG.classidof,
    SRFG.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    GREG.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_NW;
  constant AxialDir cXBI_IN_DIR = cW;
  constant AxialDir cXBI_OUT_DIR = cN;

  constant C2D cXBI_POS = { .x = -5, .y = 10 };
  constant C2D cXBI_SIZ = { .x = 3, .y = 4 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "GREEN"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 3) {
      feedad = cW;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 0 &&
        relc.x <  2 && relc.y < 1) {
      feedad = cN;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    if (fromid == GREG.classidof) return (TapIdx) bim.getTapIdxFromClassId(MRRF.classidof);
    if (fromid == GREG.classidof) return (TapIdx) bim.getTapIdxFromClassId(MLRF.classidof);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]}) ((0, 1), (1, 3))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 3) {
      C2D diff((C2D.Coord) (relc.x-0),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'W', 'outdir': 'N', 'pos': [-5, 10], 'inputs': ['SLFG', 'SRFG'], 'outputs': ['GREG'], 'axons': [['GREG', 'MRRF'], ['GREG', 'MLRF']], 'number': 1, 'origin': 'NW', 'inoff': [0, -1], 'outoff': [1, 0], 'size': [3, 4]}) ((1, 0), (2, 1))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 1 && relc.y >= 0 &&
        relc.x <  2 && relc.y < 1) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-0));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_GREEN

//NAME XBInfo_GREYS IS {'indir': 'E', 'outdir': 'N', 'pos': [-18, -1], 'inputs': ['SFLG', 'SFCG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG', 'CLOK', 'TRAKPD', 'TRAK'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG'], ['TRAK', 'MRRF'], ['TRAK', 'MLRF'], ['CLOK', 'GTCC']], 'number': 2, 'origin': 'NE', 'inoff': [0, 1], 'outoff': [1, 0], 'size': [9, 7]}
@Concrete
transient XBInfo_GREYS : XBInfo {
  constant ClassId cIN_TAPS[] = {
    SFLG.classidof,
    SFCG.classidof,
    SFRG.classidof,
    SRRG.classidof,
    SRLG.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    HFLG.classidof,
    HFRG.classidof,
    HRRG.classidof,
    HRLG.classidof,
    CLOK.classidof,
    TRAKPD.classidof,
    TRAK.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_NE;
  constant AxialDir cXBI_IN_DIR = cE;
  constant AxialDir cXBI_OUT_DIR = cN;

  constant C2D cXBI_POS = { .x = -18, .y = -1 };
  constant C2D cXBI_SIZ = { .x = 9, .y = 7 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "GREYS"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'E', 'outdir': 'N', 'pos': [-18, -1], 'inputs': ['SFLG', 'SFCG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG', 'CLOK', 'TRAKPD', 'TRAK'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG'], ['TRAK', 'MRRF'], ['TRAK', 'MLRF'], ['CLOK', 'GTCC']], 'number': 2, 'origin': 'NE', 'inoff': [0, 1], 'outoff': [1, 0], 'size': [9, 7]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 8 && relc.y >= 1 &&
        relc.x <  9 && relc.y < 6) {
      feedad = cE;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 0 &&
        relc.x <  8 && relc.y < 1) {
      feedad = cN;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'E', 'outdir': 'N', 'pos': [-18, -1], 'inputs': ['SFLG', 'SFCG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG', 'CLOK', 'TRAKPD', 'TRAK'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG'], ['TRAK', 'MRRF'], ['TRAK', 'MLRF'], ['CLOK', 'GTCC']], 'number': 2, 'origin': 'NE', 'inoff': [0, 1], 'outoff': [1, 0], 'size': [9, 7]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    if (fromid == HFLG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IFLG.classidof);
    if (fromid == HFRG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IFRG.classidof);
    if (fromid == HRRG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IRRG.classidof);
    if (fromid == HRLG.classidof) return (TapIdx) bim.getTapIdxFromClassId(IRLG.classidof);
    if (fromid == TRAK.classidof) return (TapIdx) bim.getTapIdxFromClassId(MRRF.classidof);
    if (fromid == TRAK.classidof) return (TapIdx) bim.getTapIdxFromClassId(MLRF.classidof);
    if (fromid == CLOK.classidof) return (TapIdx) bim.getTapIdxFromClassId(GTCC.classidof);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'E', 'outdir': 'N', 'pos': [-18, -1], 'inputs': ['SFLG', 'SFCG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG', 'CLOK', 'TRAKPD', 'TRAK'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG'], ['TRAK', 'MRRF'], ['TRAK', 'MLRF'], ['CLOK', 'GTCC']], 'number': 2, 'origin': 'NE', 'inoff': [0, 1], 'outoff': [1, 0], 'size': [9, 7]}) ((8, 1), (9, 6))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 8 && relc.y >= 1 &&
        relc.x <  9 && relc.y < 6) {
      C2D diff((C2D.Coord) (relc.x-8),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'E', 'outdir': 'N', 'pos': [-18, -1], 'inputs': ['SFLG', 'SFCG', 'SFRG', 'SRRG', 'SRLG'], 'outputs': ['HFLG', 'HFRG', 'HRRG', 'HRLG', 'CLOK', 'TRAKPD', 'TRAK'], 'axons': [['HFLG', 'IFLG'], ['HFRG', 'IFRG'], ['HRRG', 'IRRG'], ['HRLG', 'IRLG'], ['TRAK', 'MRRF'], ['TRAK', 'MLRF'], ['CLOK', 'GTCC']], 'number': 2, 'origin': 'NE', 'inoff': [0, 1], 'outoff': [1, 0], 'size': [9, 7]}) ((1, 0), (8, 1))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 1 && relc.y >= 0 &&
        relc.x <  8 && relc.y < 1) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-0));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_GREYS

//NAME XBInfo_CTLGREY IS {'indir': 'S', 'outdir': 'E', 'pos': [-8, -11], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SE', 'inoff': [-1, 0], 'outoff': [0, 1], 'size': [6, 5]}
@Concrete
transient XBInfo_CTLGREY : XBInfo {
  constant ClassId cIN_TAPS[] = {
    IFLG.classidof,
    IFRG.classidof,
    IRRG.classidof,
    IRLG.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    HFQA.classidof,
    HPDF.classidof,
    HPDR.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_SE;
  constant AxialDir cXBI_IN_DIR = cS;
  constant AxialDir cXBI_OUT_DIR = cE;

  constant C2D cXBI_POS = { .x = -8, .y = -11 };
  constant C2D cXBI_SIZ = { .x = 6, .y = 5 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "CTLGREY"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'S', 'outdir': 'E', 'pos': [-8, -11], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SE', 'inoff': [-1, 0], 'outoff': [0, 1], 'size': [6, 5]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 4 &&
        relc.x <  5 && relc.y < 5) {
      feedad = cS;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 5 && relc.y >= 1 &&
        relc.x <  6 && relc.y < 4) {
      feedad = cE;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'S', 'outdir': 'E', 'pos': [-8, -11], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SE', 'inoff': [-1, 0], 'outoff': [0, 1], 'size': [6, 5]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    if (fromid == HPDF.classidof) return (TapIdx) bim.getTapIdxFromClassId(MLRF.classidof);
    if (fromid == HPDR.classidof) return (TapIdx) bim.getTapIdxFromClassId(MRRF.classidof);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'S', 'outdir': 'E', 'pos': [-8, -11], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SE', 'inoff': [-1, 0], 'outoff': [0, 1], 'size': [6, 5]}) ((1, 4), (5, 5))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 1 && relc.y >= 4 &&
        relc.x <  5 && relc.y < 5) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-4));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'S', 'outdir': 'E', 'pos': [-8, -11], 'inputs': ['IFLG', 'IFRG', 'IRRG', 'IRLG'], 'outputs': ['HFQA', 'HPDF', 'HPDR'], 'axons': [['HPDF', 'MLRF'], ['HPDR', 'MRRF']], 'number': 3, 'origin': 'SE', 'inoff': [-1, 0], 'outoff': [0, 1], 'size': [6, 5]}) ((5, 1), (6, 4))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 5 && relc.y >= 1 &&
        relc.x <  6 && relc.y < 4) {
      C2D diff((C2D.Coord) (relc.x-5),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_CTLGREY

//NAME XBInfo_TILES IS {'indir': 'S', 'outdir': 'W', 'pos': [-13, -10], 'inputs': ['GTCC'], 'outputs': ['OCLK'], 'axons': [['GTCC', 'TRAK']], 'number': 4, 'origin': 'SW', 'inoff': [-1, 0], 'outoff': [0, -1], 'size': [3, 3]}
@Concrete
transient XBInfo_TILES : XBInfo {
  constant ClassId cIN_TAPS[] = {
    GTCC.classidof,
  }; // cIN_TAPS

  constant ClassId cOUT_TAPS[] = {
    OCLK.classidof,
  }; // cOUT_TAPS

  constant PocketDir cXBI_ORIGIN = cQUAD_SW;
  constant AxialDir cXBI_IN_DIR = cS;
  constant AxialDir cXBI_OUT_DIR = cW;

  constant C2D cXBI_POS = { .x = -13, .y = -10 };
  constant C2D cXBI_SIZ = { .x = 3, .y = 3 };
  //// XBInfo API
  @Override virtual String getXBInfoName() { return "TILES"; }
  @Override virtual C2D getXBInfoPosition() { return cXBI_POS; }
  @Override virtual C2D getXBInfoSize() { return cXBI_SIZ; }
  @Override virtual PocketDir getXBInfoOrigin() { return cXBI_ORIGIN; }
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) { 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }


// generateFeedDirCode({'indir': 'S', 'outdir': 'W', 'pos': [-13, -10], 'inputs': ['GTCC'], 'outputs': ['OCLK'], 'axons': [['GTCC', 'TRAK']], 'number': 4, 'origin': 'SW', 'inoff': [-1, 0], 'outoff': [0, -1], 'size': [3, 3]})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {
    mD&&pR("GFDCDindir10")&&pR(relc);
    if (relc.x >= 1 && relc.y >= 2 &&
        relc.x <  2 && relc.y < 3) {
      feedad = cS;
      isinput = true;
      return true;
    }
    mD&&pR("GFDCDindir11");

    mD&&pR("GFDCDoutdir10")&&pR(relc);
    if (relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 2) {
      feedad = cW;
      isinput = false;
      return true;
    }
    mD&&pR("GFDCDoutdir11");

    return false;
  }

// generateAxonTargetCode({'indir': 'S', 'outdir': 'W', 'pos': [-13, -10], 'inputs': ['GTCC'], 'outputs': ['OCLK'], 'axons': [['GTCC', 'TRAK']], 'number': 4, 'origin': 'SW', 'inoff': [-1, 0], 'outoff': [0, -1], 'size': [3, 3]})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);
    if (fromid == GTCC.classidof) return (TapIdx) bim.getTapIdxFromClassId(TRAK.classidof);
    return cTAPIDX_NONE;
  }


  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {
// generateTAPCheckCode(indir,inputs,{'indir': 'S', 'outdir': 'W', 'pos': [-13, -10], 'inputs': ['GTCC'], 'outputs': ['OCLK'], 'axons': [['GTCC', 'TRAK']], 'number': 4, 'origin': 'SW', 'inoff': [-1, 0], 'outoff': [0, -1], 'size': [3, 3]}) ((1, 2), (2, 3))
    mD&&pR("GXBITindir10")&&pR(relc);
    if (sensor &&
        relc.x >= 1 && relc.y >= 2 &&
        relc.x <  2 && relc.y < 3) {
      C2D diff((C2D.Coord) (relc.x-1),(C2D.Coord) (relc.y-2));
      Unsigned idx = diff.length();      mD&&pR("GXBITindir11")&&pR(diff)&&pR(idx);

      return cIN_TAPS[idx];            
    }
// generateTAPCheckCode(outdir,outputs,{'indir': 'S', 'outdir': 'W', 'pos': [-13, -10], 'inputs': ['GTCC'], 'outputs': ['OCLK'], 'axons': [['GTCC', 'TRAK']], 'number': 4, 'origin': 'SW', 'inoff': [-1, 0], 'outoff': [0, -1], 'size': [3, 3]}) ((0, 1), (1, 2))
    mD&&pR("GXBIToutdir10")&&pR(relc);
    if (!sensor &&
        relc.x >= 0 && relc.y >= 1 &&
        relc.x <  1 && relc.y < 2) {
      C2D diff((C2D.Coord) (relc.x-0),(C2D.Coord) (relc.y-1));
      Unsigned idx = diff.length();      mD&&pR("GXBIToutdir11")&&pR(diff)&&pR(idx);

      return cOUT_TAPS[idx];            
    }
    return 0u;
  }


} // XBInfo_TILES
