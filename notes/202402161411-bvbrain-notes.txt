{652}  -*-  mode: text; fill-column: 50;  -*-
[0:

Fri Feb 16 14:11:49 2024 OK so we've finally
finally finnaly kind of arrived at ulam level and
we need some API to get serious about.
[1:

Fri Feb 16 14:15:23 2024 We'd done some fresh part
on that but I forgot to push the notes file so
it's not here right now and the link seems to be
down again grr. We just have the awful
autogenerated transcript. [2:

Fri Feb 16 14:21:31 2024 Ah link is back, tx e! So
here was the main angles from this past Monday:

    PROMPT: ORGANIC ROUTING IN ULAM

    QBody
    Net
    Grip
    Terminals
    Fresh signals map to particle creation / consumption

    Term
     String mName
     Bool mFresh
     Unsigned(2) mType; // unused, sensor, motor, reserved
     union {
      Unsigned(8) mUVal;
      Int(8) mSVal;
     }

    QBody
     Unsigned(8) getNumTerms() native; //< total in term physics
     String getTermName(Unsigned(8) index) native; //< across total physics
     Unsigned(8) getTermIndex(String name) native; //< "

     Unsigned getNumVals() native; //< in this site/tile
     Term getTerm(Unsigned idx) native;

[3:

Fri Feb 16 14:33:11 2024 So I guess what I'm
looking for most immediately is stuff related to
the native methods. We now have gotten a
BrainStemSupport.{h,tcc,cpp} successfully building
here in our BVBrain physics; we want to populate
it and Uq_10109211BVBrainStem10_native.tcc now.
[4:

Fri Feb 16 14:34:58 2024 I guess a first stop
would be to just get BrainStem.ulam to start
exposing some of the BrainStemSupport methods.

Like.. [5:

Fri Feb 16 14:38:59 2024 Well wait a sec; we do
need some more basic design first.

So, we're thinking BrainStemSupport will basically
be a statically allocated singleton, which
individual native methods call into but do not
own. And we're thinking it would go a little
something like this:

Bool update() native;
 - true iff a new sm packet has been seen by stem
   since last update() call. Idea is to call this
   once at beginning of stem-related event
   processing, and it calls BSS::readInputFile()
 - It will probably check for updating tags file
   and whatever as well? And, actually, responding
   to the input by updating the output.. basically
   all of this:

        tryLoadTags();
        if (readInputFile())
          tryRouting();
        writeOutputFile();
        ++_updates;

or is it

        tryLoadTags();
        if (readInputFile())
          writeOutputFile();

or is it

        tryLoadTags();
        return readInputFile();

plus like

     Void act() {
       writeOutputFile();
     }

or something?
[6:

Fri Feb 16 14:58:57 2024 Maybe it's like open()
and close()

Bool BVBrain.open() native ->
   tryLoadTags();
   return readInputFile();

Bool BVBrain.close() native ->
   writeOutputFile()
   return true; // Void?

:6]
:5]

:4]

:3]
:2]

:1]
:0]
[7:

Fri Feb 16 23:44:33 2024 So OK. It's clear still
in this early stage of development that we really
really really want a PyBulletTime <-> mfms link
to build all this stuff.

Of fogging course.

So how would that go? Let's review the flow:

HOST
PyBulletTime/src/WorldRunner.py
 - runs the simulation
 - contains a PacketSpine which
   - contains a SerLoop which opens /dev/ttyUSB0, and
   - sends and receives packets over the wire

TILE
T2-12/base/apps/sercon/t2serloopRunner.sh
 - starts ./t2serloop.py as needed, which
   - sends and receives packets over the wire
   - reads /mnt/T2TMP/output.dat and
   - writes /mnt/T2TMP/input.dat and
   - writes /mnt/T2TMP/tags.dat

TILE/"mfmt2"
T2-12/base/apps/sercon/BrainStem.cpp
 - reads /mnt/T2TMP/input.dat and
 - reads /mnt/T2TMP/tags.dat and
 - writes /mnt/T2TMP/output.dat

[8:

Sat Feb 17 01:01:54 2024 So I think maybe a
reasonable simulation would be to like connect two
PTYs together and feed those devices to
WorldRunner.py and t2serloop.py, so everything
runs on the nominal 'host', and the API for mfmt2
and mfms is identical, going via /mnt/T2TMP.

Apparently 'socat' is a reasonably standard thing
for such tasks, which I've just installed here..

Let's learn a bit about socat for this task!

[9:

Sat Feb 17 01:20:52 2024 OK, well, modulo various
permissions issues, this

 # socat -d -d pty,b9600,raw,echo=0,link=/dev/ttyS90 pty,b9600,raw,echo=0,link=/dev/ttyS91

seems to create /dev/pts/22 and /dev/pts/23
and I can send stuff in both directions (using
echo and cat, for example).

So maybe we can make a script to set this stuff
up?

Actually let's first get some

TODO
[10: Sat Feb 17 11:54:41 2024
DONE:10] - WorldRunner.py takes optional serial device name
[13: Sat Feb 17 12:20:08 2024
DONE:13] - t2serloop.py takes optional serial device name
[14: Sat Feb 17 12:23:37 2024
DONE:14] - mfmsRunner.sh runs t2serloop.py /dev/pts/23
[11: Sat Feb 17 11:54:51 2024
DONE:11] - 'make debug' runs WorldRunner.py /dev/pts/22
[12: Sat Feb 17 11:55:01 2024 'RootWire.sh'
DONE:12] - DebugWire.sh (sets up /mnt/T2TMP) and runs socat
[24: Sun Feb 18 23:00:33 2024 so okay
DONE :24] - ulam native code does hardcoded BrainStem routing
 - come make more to-do

But first a break I think.

:9]
:8]

:7]
[15:

Sat Feb 17 12:36:42 2024 OK that actually went in
pretty easily. We're already back to ulam & native
code..
[16:

Sat Feb 17 12:44:37 2024 OK,
BrainStemSupport::tryLoadFile and ::readInputFile
both succeeded, allowing BVBrainStem.open() to
succeed. Have we got any usable api at this level?

Well, :6: above says .close() should write the
output file - are we doing that?[17:

Sat Feb 17 12:55:47 2024 OK now we are. Have we
got ANYthing useful for ulam sensorimotor api?
[18:

Sat Feb 17 12:57:06 2024 I guess it's :2: above
from a fresh part. Maybe something related to

    QBody
     Unsigned(8) getNumTerms() native; //< total in term physics
     String getTermName(Unsigned(8) index) native; //< across total physics
     Unsigned(8) getTermIndex(String name) native; //< "

     Unsigned getNumVals() native; //< in this site/tile
     Term getTerm(Unsigned idx) native;

to proceed, here?[19:

Sat Feb 17 13:02:43 2024 OK we can't really want
String as the return type for getTermName, can we?
We don't think we can add Strings at runtime, and
we don't want to go down the road of wanting that.

:19]

:18]
:17]

:16]
:15]
[20:

Sun Feb 18 00:43:47 2024 OK, so, we've gotten this
far:

    20240218003906-269: 0AEPS [726FA197]MSG: print: Bool(3) 0x7 (true)
    20240218003906-270: 0AEPS [726FA197]MSG: print: "OPENED"
    20240218003906-271: 0AEPS [726FA197]MSG: Tag#0:[BVACT]
    20240218003906-272: 0AEPS [726FA197]MSG: Tag#1:[BVPITCH]
    20240218003906-273: 0AEPS [726FA197]MSG: Tag#2:[BVREQ]
    20240218003906-274: 0AEPS [726FA197]MSG: Tag#3:[BVROLL]
    20240218003906-275: 0AEPS [726FA197]MSG: Tag#4:[FLWHEEL]
    20240218003906-276: 0AEPS [726FA197]MSG: Tag#5:[MLR]
    20240218003906-277: 0AEPS [726FA197]MSG: Tag#6:[MRR]
    20240218003906-278: 0AEPS [726FA197]MSG: Tag#7:[SLFL]
    20240218003906-279: 0AEPS [726FA197]MSG: Tag#8:[SRFL]
    20240218003906-280: 0AEPS [726FA197]MSG: Tag#9:[SUPL]
    20240218003906-281: 0AEPS [726FA197]MSG: print: Bool(3) 0x7 (true)
    20240218003906-282: 0AEPS [726FA197]MSG: print: "CLOSED"

generated by an event running BVBrain.behave().
The code isn't pretty; the api ain't the nicest..
but the code runs.

So. How much more do we need before ulam routes a
signal?

Well how are we going to access term values? That
doesn't exist. Are we going to have a quark to
represent a term?[21:

Sun Feb 18 01:03:53 2024 Well what might that look
like?

quark SMTerm {
  Unsigned(2) mType; // none, sense, motor, both(?)
  ASCII mIndex;
  ASCII mValue;
}


:21]

:20]
[22:

Sun Feb 18 05:45:05 2024 Well, it's an utter hack,
but technically speaking we are now routing via
mfms and ulam events. With like:

    element BVBrain {
      BVBrainStem mBS;

      Void behave() {
        if (!mBS.open()) return;
        SMTerm tSLFL = mBS.readTermByName("SLFL");  // senses
        SMTerm tSRFL = mBS.readTermByName("SRFL");
        SMTerm tMLR = mBS.readTermByName("MLR");    // motors
        SMTerm tMRR = mBS.readTermByName("MRR");
        tMLR.setValue(tSRFL.getValue()); // good ole
        tMRR.setValue(tSLFL.getValue()); //  BV 2b
        mBS.writeTerm(tMLR);
        mBS.writeTerm(tMRR);
        mBS.close();
      }
    }

and merges/20240218-034359.mp4 is collecting the
results..

:22]
[23:

Sun Feb 18 11:02:54 2024 So, could we record mfms
captures somehow synchronized (at least by name)
to the PyBulletTime captures?

Could have a 'seconds spinner' sense that supplies
say the last 8 bits of the unix epoch, and have
BrainStemSupport.tcc read the rest of the time and
generate a filename and take a picture for that
name?

It would be running in the middle of an event; not
sure we've ever tried to render the grid at that
point; smells quite risky.

Perhaps we could set up a trigger asking mfms to
take a shot? Then it would do that between events?

Or maybe we just send the cadence? So 2 means
every even second, 5 means 0%5 seconds, etc. Then
the native code triggers a grab somehow that mfms
can do but mfmt2 can ignore..

:23]
[25:

Sun Feb 18 23:00:51 2024 OK, so we need more

TODO
[26: Mon Feb 19 01:22:39 2024 not offsets
DONE :26] - toml sets cadence (and perhaps process
   offsets?)
[27: Mon Feb 19 01:22:48 2024
DONE :27] - SecondsStep respects the cadence
[28: Mon Feb 19 01:59:08 2024 inband 'CADENCE' tag doh..
DONE :28] - t2serloop.py:indexConfig() respects the
   cadence, generating OoB tags perhaps?
[29: Mon Feb 19 02:11:47 2024 i think, anyway,
DONE :29] - make branch for existing 'V6' hacks and
   get rid of them for now
[30: Mon Feb 19 03:02:55 2024
DONE :30] - make some public MFM//gui method for requesting
   a render to a given path
[39: Wed Feb 21 23:40:48 2024
DONE :39] - have BrainStemSupport offer a cadence/phase
   tracking thing to detect first call 'on the
   beat' and request mfms render
[40: Wed Feb 21 23:40:59 2024 'newSenses()'
DONE :40] - BVBrainStem.open() calls actionsOnTheBeat() or
   whatever it's called
[41: in toml script, [config]/snapshotdir
DONE :41] - render mfms shots somewhere accessible
[42: in render15.pl
DONE :42] - make a script that makes links (?) to match
   a data/SIM-TAG, filling in transparency or
   something for misses (?)
[43: Wed Feb 21 23:42:05 2024
DONE!! :43] - watch a merge video of a BV2B run routed by
   mfms, with mfms screenshots synced
[46: Wed Feb 21 23:50:28 2024
DONE :46] - come make more to-do

:25]
[31:

Mon Feb 19 03:06:09 2024 OK how to we get to
AbstractGUIDriver from Uq.._native code?

..Add something to EventWindowRenderer?

Tired now. Later.[32:

Mon Feb 19 11:45:03 2024 Well for the life of me I
can't find any paths to the driver from src/core
or src/sim. Now I recall we tried hard to avoid
them but I didn't really think we had been so
successful..

Hmm what about in platform-specific?[33:

Mon Feb 19 11:53:38 2024 Well platform-specific is
pretty clean and essential and we're certainly not
going to fuck that up for this.
[34:

Mon Feb 19 11:54:44 2024 Do we really make a
static GetDriver * kind of thing? [35:

Mon Feb 19 12:00:16 2024 OK I found the
ever-so-slightly-suspiciously-named XXXDRIVER in
drivers/mfmc/src/main.cpp. It's declared at file
level but neither extern nor static. Can we see it
from native code?
[36:

Tue Feb 20 00:11:07 2024 Well, I tried to hack
stuff in around the XXXDRIVER but couldn't get
various multiple inheritance + dynamic_casting
abominations to work.

So I'm thinking of going back to src/core, and
making an 'official' rat hole extensions
mechanism. Something like

 virtual void * globalExtension(const char * name, void * arg) {
   return 0;
 }

which everybody can override with like

 virtual void * MINE::globalExtension(const char * name, void * arg) {
   MFM_API_ASSERT_NONNULL(name);
   if (!strcmp(name,"FOO")) return doFOO((Foo*) arg);
   return Super::globalExtension(name,arg);
 }

or however that goes in C++ (been a while gah).

Except, except, except, that there's no top-level
object in src/core, right? That was kind of a
deliberate point wasn't it?

It could be like a singleton 'Hooks' thing that
people add their own hooks to?

struct GlobalHook {
  const char * m_name;
  virtual void * hookHandler(void * arg) = 0;
  struct GlobalHook m_next;
};

class GlobalHooks {
public:
  static GlobalHooks& getSingleton();
  void addHook(GlobalHook & hook) {
    MFM_API_ASSERT_NONNULL(hook.m_name);
    MFM_API_ASSERT_NULL(hook.m_next);
    hook.m_next = m_head;
    h_head = &hook;
  }
  void * runHook(const char * name, void * arg) {
    MFM_API_ASSERT_NONNULL(name);
    for (GlobalHook p = m_head; p; p = p->next)
      if (!strcmp(name,p->m_name)) return p->hookHandler(arg);
    return 0;
  }
private:
  GlobalHooks() : m_head(0) { }
  GlobalHook * m_head;
};

:36]

:35]

:34]

:33]

:32]

:31]
[37:

Wed Feb 21 01:48:10 2024 Well, it looks like we
have mfms snapshots named by the cadence second,
getting stored in a toml-configured directory.
We're accummulating some now. We ought to be able
to come up with a modified script that will let us
find snapshot matches and merge them into the bv
movie somehow. Need to generate placeholder links
for missing matches, I guess. Probably generate
links for every frame, actually..[38:

Wed Feb 21 23:28:21 2024 aaaand we have
render15.pl now integrating time-matched mfms
screenshots into the rendering. Have a few samples
in 3148-20240305/sources/beevee/mfmsbrain/

Let's claim some to-do?

:38]

:37]
[44:

Wed Feb 21 23:42:20 2024 OK so we need more

TODO
 - checkpoint BVBrain, PyBulletTime, MFM, and co
[50: Thu Feb 22 11:42:16 2024 not super tested but
DONE :50] - extend BrainStemSupport somehow to have a
   newSenses(index) for per-sensor 'newness' not
   just per SM packet
[49: Thu Feb 22 11:41:54 2024 did some anyway
DONE :49] - think about routing designs for real
[69: Thu Feb 29 01:41:22 2024 well, basically
SKIPPED :69] - spike one or two exotic possibilities to stanch
   the dreaming
[70: Thu Feb 29 01:41:32 2024
DONE :70] - commit to a first routing design
[72: Thu Feb 29 02:07:21 2024
DONE :72] - come make more to-do

:44]
[45:

Wed Feb 21 23:48:29 2024 didn't realize we need
per-sensor newness until making up that to-do.
Let's just look at that first.[47:

Wed Feb 21 23:58:28 2024 Hmm but right now we've
tied the snapshots to the newSenses() call. Need
to move that to open or something instead, so the
first caller to open when there's new senses
requests the snapshot, but all the individual
senses remain new.

I'd changed BSS::newSenses() to anyNewSenses() but
maybe it should be something directly related to
snapshots..
[48:

Thu Feb 22 00:01:50 2024 Right now there's no
open/close abstraction in BrainStemSupport -
that's just laid on in the BrainStem native code -
but maybe there should be?

 open:
  - try load tags, and
  - try load config, and
  - readInputFile, and
  - requestSnapshot if inputfile is new, and
  - that's all?

:48]

:47]

:45]
[51:

Thu Feb 22 11:42:36 2024 So, we've imported the
Intender APIs from Ancestor211. It does seem to
help organize things. We're applying it to a
'Cloud' API that we are spiking for a non-rigid
hop-count-based 'routing ether'.

I'd like to emphasize cloud particles shifting and
spreading without necessarily always growing and
shrinking. Want to try to lean into 'gas
pressure'. Want to potentially have a gas cloud
expand and contract from the center, and spread by
jiggling, rather than growing at the periphery.

Let's try to demonstrate just that much. Some kind
of pressure estimator, plus some kind of desired
pressure gradient, plus jiggling to match local
pressure conditions.

So to do that, what kind of transition phases are
we looking for?

[52:

Thu Feb 22 11:56:05 2024 Well let's say first: How
do we estimate pressure and what do we want our
pressure gradient to be?

Perhaps we get non-'round' (ie diamond) gradients
because we'll integrate multiple hopcounts from
different anchors in a signal point.

So, pressure = (endopressure + exopressure) / count of available sites

endopressure = count of 'us'
exopressure = count of non-us non-empty

Perhaps it would be helpful to think it terms of
pressure 'bands'. Like minpressure/maxpressure
ranges for different hopcounts

aaand also do we even need much gradient? vs
constant pressure out to K hops and then 0 beyond
that?

aand are we also presuming something like 'stable
downs', where the center gets some idea how the
gradient is doing? so if we want constant pressure
out to 6 hops, and the guys at 3 hops are already
at minpressure..

so could we have the signals be 'position in
pressure band'? If downstream is hitting the
bottom of the band, that pulls upstream down, and
so forth, until a root sees underpressure and it
emits more cloud to adjust.

so let's just focus on endopressure first. We're
acting like we can examine ngbs pressures so it
needs to be represented somehow.

1 in 41 is ~2.5%

could 31 of 41 be the maximum possible density? ==
~76% ? Five bits directly interpreted? (Assuming
the ew is fully available.)

and a pressure band could be maybe 3 or 5
consecutive values in 0..31? Center + width

pressure band
  0..2 -> 0% -> ~5%
  1..3   2.5% -> 7%

[53:

Thu Feb 22 16:41:15 2024 OK need some kind of
pressure rule immediately to code up. Like
max(0,4-chops/2) or something?

And what about going the other way? What about
having the density increase with distance?
Auto-membrane, like..
min(2,chops/2) up to chops 8 or something?
[54:

Thu Feb 22 23:18:42 2024 OK so it's easy to
imagine not moving too far away from your
minchops, but what about our minchops moving away
from us and creating a disconnection?

We could represent our minchops explicitly, so
they could tell we were counting on them. That
would give us a general tree. We could assemble
our children's SNs in a side array during observe.

But that also drives home that minchops should be
the closest-lowest up that we see, not just the
lowest, right? Otherwise we'll get pinned by
EW chop jumpers that can just barely see us?

 (1) It's an us
 (2) it's as close as any other us
 (3) it's minchops among those

:54]

:53]

:52]

:51]
[55:

Fri Feb 23 00:28:49 2024 OK I need something
simpler and/or using more existing code.

[56:

Fri Feb 23 04:01:17 2024 Well we made 'Gridder'
which does a land war style thing to resolve phase
inconsistencies in favor of the larger area
competitor. Works pretty well although long-lived
stalemates are possible, with the battle line
straightening and stagnating.
[57:

Mon Feb 26 23:17:55 2024 It's interesting how
there seems to be an inherent scale in a given set
of rules for power production, storage, and
logistics. Beyond a certain distance from a
stagnant battleline, it doesn't matter whether you
have a lot more area or not farther back.

It's like you're already flowing as much as you
can toward the line, but your local storage
capacities, far behind the lines, are still maxed
out anyway. One side could have thousands more
tiles back there, and the other just a few, but
both sides look the same at the battleline, so it
remains stagnant, and we have the forever war.

:57]
:56]

:55]
[58:

Tue Feb 27 06:41:30 2024 So we're back to Beevee's
brain tissue and we're really wanting to be able
to assign terminals to different tiles in mfms..
grr.

Maybe we could make some elements that 'sensitize'
their tile to a particular terminal. Then have the
brain tissue 'pick up' those assignments as it
spreads. So we'd use initial conditions of those
elements to simulate per-tile terminal deployment.

Let's give it a try anyway.
[59:

Tue Feb 27 07:23:43 2024 Well it seems plausible
so far. Just declaring gradients for motor
terminals for now; step by step.

Let's try to build the gradients!
[60:

Tue Feb 27 07:58:15 2024 OK, so, how are we going
to get backwards from a 'gradient index' to the
term that gradient is pointing at? All we have is
getting the index from a given subclass instance
of Terminalias. Do we have to do ClassUtils
shenanigans to iterate over subclasses?
[61:

Tue Feb 27 08:04:22 2024 Ooh, it looks like a
constant array of .classidof's might do the trick?
(Except for the messiness of having to maintain
numbers in two places..)

:61]
:60]
:59]

:58]
[62:

Tue Feb 27 15:28:01 2024 SO. We have a BV2B
running 'non-trivially' in ulam on mfms, with
Signal particles getting routed from SRFL and SLFL
to MLR and MLR terminaliases.

I came here to start discussion about how to make
the routing programmable but an answer already
seemed to now be obvious: We could have a centrol
clump of 'controller' tissue, and all sensors
would their route signals towards controller
tissue, and the first controller that sees a given
signal reconfigures it according to the current
control program, and that reconfigured signal just
carries on towards its newly appropriate
destination.

[63:

Tue Feb 27 15:39:24 2024 I want to make a say red
border near the edge of the universe, and let
Beevee detect red also (on his same cameras,
during the same sensing stage).

How do we do that with the current setup?
[64:

Thu Feb 29 00:39:31 2024 Got that working with a
larger 'subplane' urdf file although I think
there's a hopefully-now-small step when rolling
off the checkerboard onto the red subplane.

Plus got red detection, redid the terminal names
to include 'Y'ellow vs 'R'ed info, and redid the
car views to include Y and R numbers. Could add B
or G or whatever pretty easily later.

[65:

Thu Feb 29 00:40:22 2024 But anyway, the reason
I'm here is that so far, Beevee's brain isn't
reconfigurable; it's hardcoded 2B routing and
Beevee can't change his mind.

Today we at least design something to change that.

My first idea is to route SLFY and SRFY (for
starters) along a new gradient to a 'controller'
region of some sort, which can change what
algorithm it's running. The controller reroutes
signals based on its grip, and when the grip
changes, the routing changes accordingly.

Now at one point I was hoping that the routing
could happen 'in the grid' in some decentralized
way, while still having some broadcast flood
method for changing the algorithm. But that
assumes there's no state beyond the choice of
algorithm itself, or all that additional
parameterization must be flooded too, and it all
gets ucky.

But I don't want to go to a single atom for the
controller. I want a controller region.

One idea was like layers:

    SLFR                       SRFR

    SLFY                       SRFY

          C1  C1  C1  C1  C1

          C2  C2  C2  C2  C2

          C3  C3  C3  C3  C3

          C4  C4  C4  C4  C4

  MLRF                        MRRF

  MLRR                        MRRR


where the S??? terminals would all route to C1,
at which point C1 would transform the signal in
some ways, which could include:
 - drop it
 - copy it
 - redirect it
 - change its type
 - change its value

and in particular a say C1 could reroute a Sig to
a say C2, for SEQUENTIAL FOGGEN PROCESSING ahem.

It would also be fun to keep (copies of) certain
signals to use for state comparisons and such. If
such 'captured signals' could be a/the main method
of representing additional state.

[66:

Thu Feb 29 01:32:03 2024 FOR EXAMPLE: Suppose that
seeing a SLFR or SRFR (of sufficient strength)
would lead to capturing it and gradually
decreasing its strength. And so long as it was
captured (and sufficiently strong) it would switch
the controller to BV2A routing red to forward.

When its strength got low it would be deleted, and
that controller would revert to BV2B routing
yellow to forward.

[67:

Thu Feb 29 01:36:13 2024 That's a good example in
the sense that, although 2A(SRxMF) actually needs
to consume SY to keep things clean, in another
context I guess it could be rerouting them a
significant distance, from X cross-routing to P
parallel routing or back.

Not an absolutely great example perhaps.

[68:

Thu Feb 29 01:40:20 2024 But this all feels pretty
implementation. Do we have prior to-do to claim?
[71:

Thu Feb 29 01:41:43 2024 OK now some

TODO
[94: Sat Mar 16 23:03:02 2024
DONE :94] - Rename MLR/MRR -> MLRF/MRRF
[95: Sat Mar 16 23:03:14 2024 Done, regretted,
NOT DONE :95] - Add motors MLRR/MRRR
 - Evaluate what having a non-motor gradient
   anchor would involve
 - Implement a 'C1' like anchor
 - Redo sensors to signal C1
 - Have C1 reroute signals to MLRF MRRF
 - Observe BV2B behavior via C1
 - Come make more to-do

[73:

Thu Feb 29 02:07:40 2024 OK that's a fair chunk.
But let's sabre a bit first to clear the head.[74:

Thu Feb 29 02:40:00 2024 OK good run.

:74]

:73]

:71]
:68]

:67]

:66]

:65]

:64]

:63]

:62]
[75:

Thu Feb 29 03:01:01 2024 Well, was just trying to
do an 'easy one' - the renaming of MLR/MRR and
adding the reverse terminals.. But of course it's
not so easy. The Spine indexing (for one example)
assumes at most one terminal per joint.
[76:

Thu Feb 29 23:01:03 2024 OK we're going to ditch
the two-channel motors idea for now anyway, and
just rush on to the non-motor gradient anchor.

I'm not quite sure how to back out of the motor
naming stuff though.. Branch maybe.
[77:

Thu Feb 29 23:21:52 2024 Well it looks like all
the changes in BVBrain are (almost) about adding
red and could go in okay..[78:

Fri Mar  1 00:17:29 2024 PyBulletTime and the
.toml is more complicated..

..most of it wants to go in, I think..
..the 'scale' stuff seems okay

[79:

Fri Mar  1 00:19:31 2024 Well fog it let's commit
it all and see where the chips fall. We'll just
not define the reverse motors in the .toml and
hope for the best for now.

[80:

Fri Mar  1 02:10:12 2024 Aand all that revealed a
preexisting bug that took until just now to find:
When BrainStemSupport::writeOutputFile() rewrote
/mnt/T2TMP/output.dat with the updated term info,
it was failing to include O_TRUNC when it opened
the file.

So what?

Sooo, if output.dat had previously grown longer --
somehow somehow perhaps due to extra terms that
have now been removed say -- then writing the
current now shorter packet did not shorten the
overall file.

So what?

Well, t2serloop.py uses the length of the
output.dat file to check that it matches the
packet it is working with.

And all those checks were failing because
output.dat was four bytes longer than it was
supposed to be.. and so Beevee never saw any motor
commands and just sat there.

Well, that one is now fixed. O_TRUNC.

:80]

:79]

:78]

:77]
:76]
:75]
[81:

Sat Mar  9 11:16:21 2024 OK so we want to go to
smallish diamond grids around terminals, and
explicitly dig into interphase relationships,
rather than shunning them.

Let's see if we can hold a little smolness and
cleanliness rather than importing wholesale from
Ancestor14234..

There are some key simplifications we want at the
outset. In particular, we're saying (I do think)
that we don't need full mobility, just
'growbility', where we move the root (a whole
hop), and the gradient updates, and the periphery
expands or withers as appropriate.

Let's aim at that first -- we've done it multiple
times before -- and then refactor as we see what
else we want.
[82:

Sat Mar  9 11:42:26 2024 First goals:
[84: Tue Mar 12 02:10:45 2024
DONE :84] - Grow uncontested local space

[83:

Sat Mar  9 11:43:24 2024 ..aand I guess yes, let's
embrace Intentions up front (goodbye smol gah).

:83]

:82]

:81]
[85:

Tue Mar 12 02:18:08 2024 So we have size 7
'grobile' diamonds shuffling around. They run into
each other and don't care - whether they're in- or
inter- phase.

But not really clear what to do now.. nap.

[86:

Tue Mar 12 13:04:02 2024 Left a long mfms run
going and observed that once two on-phase grobiles
were adjacent root-to-root, they seem to never
move anymore. And I think that's due to the root
motion algorithm - it swaps with a min neighbor,
which will always be an adjacent on-phase root, if
one exists, so the swap changes exactly nothing..

So two or more on-phase adjacents automatically
stop moving.. if that's useful for something..

[87:

Tue Mar 12 15:23:42 2024 Could we make grobiles
move away from each other and from walls? Would we
even want such behavior if we could?
[88:

Tue Mar 12 15:25:29 2024 I think we'd want it to
move toward max LHopsOut..
[89:

Tue Mar 12 15:34:03 2024 OK we have them moving
away from edges I think, but nothing about other
grobiles. How would we want to deal with that?[90:

Tue Mar 12 15:57:47 2024 I guess also step away
from interphase stuff, which we're already
observing but not using the observations.

:90]

:89]
:88]
:87]

:86]

:85]
[91:

Thu Mar 14 07:55:22 2024 OK we made a start at
PhaseWorm, for more generalized signals, but how
do we proceed? What are we thinking are our key
points?

 - Phase worm in diamond always travels three
   steps orthogonally - so whatever phase it's in,
   it remains in that phase

 - We imagine some kind of scheduling/routing
   mechanisms for assigning phases. Like maybe
   even-in, odd-out? But we were thinking about
   point-to-point routing in local space, not just
   in/out..

 - Or maybe

[92:

Thu Mar 14 15:25:31 2024 If we did actual 'wiring'
instead of assuming free PhaseWorm packets, we
could actually count on signal delivery order,
which might be a useful thing, especially if we
start thinking about going sequential.

Take the front off, activate it in context, and
let it interact with the new front thus exposed.
So one could, for example, push an inverter on the
front of a signal.



:92]

:91]
[93:

Sat Mar 16 23:01:37 2024 OK dammit lost days here
screwing around without enough direction. Fix That
Now Soldier.

[96:

Sat Mar 16 23:03:49 2024 OK, the remaining
existing to-do doesn't describe where we are at,
which is trying to get swapworm stuff - here
called PhaseWorm at present - working in some
usable way.

Now, I think we are going to need non-Phase worm
as well, for routing paths between phase
diamonds. And that's a 'pretty standalone' task
(ho ho). Could we focus on just getting those to
exist?

FreeWorm TODO[98:
DONE :98] - Review[97:

Sun Mar 17 13:03:38 2024 OK well the review didn't
find much besides SwapWormHC3, but now we have
little FreeWorms wandering about randomly in empty
space. [99:

Sun Mar 17 13:35:34 2024 So now we need more

TODO
[106: Wed Mar 20 00:00:18 2024
DONE :106] - Implement basic middle segment behaviors
[107: DONE  :107]   = tmpup
[112: Thu Mar 21 03:12:36 2024
DONE :112] - Consider 'intermediate' middle segment
   behaviors like path straightening
[113: Rejected as not minimal
NOT DONE :113]   = Support for checking how many ahead and
     behind segments are in our ew. If enough to
     modify path, consider it.
[143: Thu Mar 28 01:13:53 2024
DONE :143] - Create 'anchored' segments that (try to) stay
   inside (the edges of) PhaseDiamonds
[144:
DONE :144] - Spike a demo that creates two PhaseDiamonds and
   lets them drift apart, connected by an anchored
   FreeWorm.
[145: Thu Mar 28 01:14:34 2024 Worm tangling dampened the fun tho
DONE :145] - Fucking enjoy seeing that running
 - Come back and make more to-do.

:99]

:97]

:96]

:93]
[100:

Mon Mar 18 00:17:51 2024 OK, come on let's get
tmps moving.[101:

Mon Mar 18 00:24:14 2024 OK so now I'm questioning
the three-way (tmpup, tmpdown, content) getType()
design. I think it wants to be two Bools (mSwapUp,
mSwapDown) instead.

But we do also want a tmp vs content distinction,
for altering the path length, if nothing else.

segments with mTemp can be deleted or arbitrarily
swapped by worm control. segments with !mTemp
cannot be deleted by worm control, and can only be
swapped in accordance with their mSwapUp and
mSwapDown.

We'd like to get bidirectional !mTemp movements,
so downstream can inject mSwapUp feedback into the
worm, and it will migrate upwards as signal
packets (for example) migrate downwards.

:101]

:100]
[102:

Mon Mar 18 11:00:37 2024 Could we make a little
'explorer' worm, that would have its tail anchored
in a phase diamond and it would grow randomly
until it encountered a (um, 'different') phase
diamond? How the hell would it avoid itself?

[103:

Mon Mar 18 11:17:58 2024 Stay on the leader. We
don't even have any middle semantics running
yet. For which we want:

 - examine both up and down.. actually, could we
   jump a little to examining as far up and down
   as remains inside the ew?

[104:

Mon Mar 18 12:17:10 2024 Well gave up on the
general case thank minimal minimal, without too
much time lost, but now facing the specific cases:

 - when can we swap up?
   = have up, and up is FWB
   = have down, and down is FWB
   = up is getCanSwapDown()
   = down is getCanSwapUp()

 - when can we swap down?
   = same same?

[105:

Tue Mar 19 01:13:52 2024 OK well we've been
merrily swapping up and down for several hours
here. Also added random pastel colors and
renderGraphics lines to see the link structure.

:105]
:104]

:103]

:102]
[108:

Wed Mar 20 00:39:25 2024 OK, refactored some in
preparation for combining different FreeWorm
types.. Going for path straightening now.
[109:

Wed Mar 20 12:26:30 2024 Well it appears path
straightening worked first time? After syntax
problems. Eventually I saw a wrong connection, but
that might have been me because I was screwing
around with it by then.[110:

Wed Mar 20 16:12:39 2024 OK now we have malformed
FWs erasing themselves (eventually).

Let's go for path length adjustments, and then I
think we'll be about set for basic FreeWorm middle
semantics. And it'll be time to deal with
customized ends.

So, when seg[0] and seg[2] are no more than 2
apart, and we are a temp, we can delete ourselves
and stitch the two of them together.

Also, when seg[0] and seg[1], or seg[1] and
seg[2], are 4 apart, we can introduce a new temp
in between them.

:110]

:109]

:108]
[111:

Thu Mar 21 03:06:53 2024 OK, well I think we have
all the basic freeworm behaviors we wanted, short
of anchored ends. Must be some to-do to claim..
[114:

Thu Mar 21 03:13:21 2024 Well a couple. Need
anchors. Do we have much idea how they'll work?

I guess simplest would be they just try to stay in
the pocket of a phase diamond, possibly stretching
the FW to do so.

So, like a head, except instead of moving
randomly, they move towards the outer ring of
whatever phase diamond they see.

How could we seed such a thing between two PDs,
though? It would be good if PDs could identify
themselves for example by the terminalias that
supports them (assuming we play it that way).

:114]
:111]
[115:

Thu Mar 21 14:06:02 2024 What about an FW that
remembers its starting location (say, a PD) and
just wanders about until it encounters a goal
(say, a different PD), and then it tries to string
a line back to its starting location?

:115]
[116:

Fri Mar 22 15:45:40 2024 OK, we've got a
substantial chunks of quark FWSearchBase and
element PDSearcher, which random walks to some
(sufficiently distant) PD. Now we need to string a
line back to our starting point. And the first
step of that is having a 'tail anchor' to plant.

And we'll need a 'head anchor' when we get to the
other end. So we need some common behaviors.[117:

Sat Mar 23 11:45:46 2024 OK, so we tried deploying
an anchor but we didn't hook it up to anything,
and testing that reminded us that our PDSearcher
might have an arbitrarily long tail of FWTDs out
behind it.

So I think the more obvious thing would be to make
a WormBuilder separate from the PDSearcher, and
deploy a configured-to-return WB and kill the
PDSearcher, when the search succeeds.
[118:

Sun Mar 24 01:09:23 2024 OK, so we have a
WormBuilder that builds a worm to mAnchor and then
decays into a PDHeadAnchor. Now we just need our
searcher to configure and release one of these
when the search succeeds.[119:

Sun Mar 24 01:39:59 2024 OK, so we got a
PDSearcher to stumble onto a neighboring PD and
successfully string a freewom back to the PD where
it started.

Now we need the PDHeadAnchor and -Tail- to
hillclimb to stay nearish the root of the PD.
[120:

Sun Mar 24 02:04:12 2024 Aand how is that going to
work? We'll scan for LocalSpace and pick min and
max hops, maybe? And then head towards one or the
other if they're out of our desired window?

Let's try it.[121:

Sun Mar 24 03:00:53 2024 Not clear how we want to
navigate in localspace without all the Ancestor
infrastructure.. We want to come up with an
in->out vector and pick distances from that
somehow. Nap.[122:

Sun Mar 24 10:28:59 2024 OK well we got the
PDAnchors hillclimbing to stay in the meat of
their PDs, and we have a 'long' run going for a
video. [123:

Tue Mar 26 10:10:44 2024 Well so we're having
troubles keeping the anchored FWs from tangling
in knots. [124:

Tue Mar 26 10:56:30 2024 What if we had five
gradients total - one toward the center and one
toward each corner, and each corner one could have
a single terminalias code representing what's
connected on that edge.

How big are terminalias codes at this point?[125:

Tue Mar 26 10:59:32 2024 Well it looks like
'Unsigned' at this point.. But nobody's
representing it explicitly, I think. Suppose we
did 5 bits for 32 signals? That's not too lame,
right? We're only using like 4 or maybe up to like
10 any time soon.

Suppose we use 6 for 64 signals plus 3 for a
distance? SpikeLocalSpace currently has 52 bits
available, so we could do five if we wanted.

[126:

Tue Mar 26 11:28:47 2024 Or what if we just
tracked the K nearest gradients? We'd keep local
space hops for overall structure, but gradient
stabilization would represent min+1s of the K
'minnest' neighboring gradients.

Be kind of nasty code for it; basically sorting
every time.

Point is that we could have >K gradients total,
with only K gradients per LS.

[127:

Tue Mar 26 11:38:46 2024 We are one week out. We
are far past time to be clever.

We can take what we have, but make the overall
grid be finite - maybe radius 32 (==96 in sites) -
and use the existing motor gradient stuff over the
whole thing. How many of those gradients could we
fit in?[128:

Tue Mar 26 11:57:32 2024 So I guess we're talking
about Tissue, here, and it currently has 7 six-bit
'Gradients', with strictly hard-coded meanings
each one.

It relies on Terminalias.cCLASSIDS_OF_GRADIENTS to
map from position to classid, so that's where the
mapping is defined.

[129:

Tue Mar 26 12:01:37 2024 So suppose we do this:

 - Add a couple more motors and 'control centers'
   ('hidden units'), like say
 - maybe have the center of the LS be the 'mind
   control center'?
 - Put a mind control receiver near each sensor
   (or at all terminaliases perhaps)
 - Have the mind control center broadcast changes
   of mind down the LS gradient.
 - Have the mind control receivers pick up the
   current mind code/instructions
 - Have the mind control receivers detect fresh
   signals, map them to motor destinations
   according to the current mind, and inject them
   into LS.
 - Motors receive the transformed signals directly
   (and/or via local mind control receivers)
 - Send something of summary info up to mind
   control center.
 - Have mind control change its mind based on
   available summary info.
 - Profit. Big fun.

[130:

Tue Mar 26 13:27:12 2024 Break in big cooking.. So
when will Beevee change its mind?

 - avoiding the edge could be standard subsumption
   fare. Turn away from red inhibits or overrides
   any yellow responses [131:

Tue Mar 26 14:46:29 2024 And I guess 'hunt' could
be the default response - and how does that work
in Braitenberg land? [132:

Wed Mar 27 00:05:46 2024 How do we get a 'random'
walk in Braitenberg land? (Or a Levy flight wevs.)

I guess maybe we'd use a lot of gain and clamp on
small differences or something?

Now, specifically in this case, we'd maybe want to
use SUPY for overall gain
[133:

Wed Mar 27 00:18:52 2024 We want hidden units for
state. We should have special little integrator
gubbins that we can target like motors, and we can
drive the state units towards particular value
combinations. The state units in turn stabilize or
somehow control the routing that the signals
make. We want some hysteresis in our decision
making, so there'll be come kind of
hidden unit farther-from-0.5 encourages other
hidden units to gecome farther-from-0.5 as well.

The simplest case is no hidden units.
But we're saying here that implies no mind.

One hidden unit could reinforce itself:

       /---> out
       |
     +---+
in-->|   |<-\
     +---+  |
       \----/
        o=w*(i-0.5)

Two hidden units could reinforce each other:

       /---> out1           /---> out2
       |                    |
     +---+                +---+
in1->|   |           in2->|   |
     +---+                +---+
      | ^     o=w*(i-0.5)  | ^
      | \------------------/ |
      \----------------------/
        o=w*(i-0.5)

[134:

Wed Mar 27 00:39:32 2024 Well but that's not
right. That encourages the two hidden units to be
the same as each other, when we just wanted to say
that when one is far from 0.5, that should
encourage the other to also be far from 0.5.

We want the self-feedback of the single hidden
unit, plus cross-connected interactions to set the
w's. The farther I am from 0.5, the harder you are
driven away from 0.5 in whatever direction you're
already going.[135:

Wed Mar 27 02:43:54 2024 Buuuut we're just going
to implement hidden units as single special atoms
that do hysterical integration all internally,
right? Right? It's WEDNESDAY BEFORE T2SDAY man.

So we'll take signals like motors do, and update
our state internally, and broadcast our state to
everybody all the time. And it changes when it
changes, and everybody hears about it when they
hear about it, and change their behavior if the
new state makes some kind of difference to them.

And we'll put the outbound state into the
LocalSpace atoms and flow it from the foggen
center. You know how to do this stuff man just do
it. You don't need new stack design in this
instance. You don't you don't. Just hack.

:135]

:134]

:133]
:132]

:131]

:130]

:129]

:128]

:127]

:126]

:125]

:124]

:123]

:122]

:121]

:120]
:119]

:118]

:117]

:116]
[136:

Wed Mar 27 04:44:48 2024 OK so we templated
LocalSpaceT and made BrainSpace that reaches out
to radius 35 (in 3x3s) which looks like it ought
to be ample for the next demo.

BrainSpace currently has 55 bits available -

  /*__________________________________________________
  | COMPONENTS of BrainSpace <17> (16 bits/55 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 13	| super	| LocalSpaceT(6u,35u,1u) <19>
  | 13	| 0	| base	| UrSelf <0>
  | 13	| 0	| base	| Intender <61>
  | 13	| 0	| base	| LocalSpace <48>
  | 13	| 3	| base	| QDebugUtils <39>
  |___________________________________________________

and I'm imagining we could have like 8
destinations at 6 bits each plus 6 bits of 'mind',
and we'd have one bit left for pinky swears.

leftmotor
rightmotor
lefteye
righteye
leftmouth
rightmouth

hmmmmm could we factor that
destinations:
  left
  right
 x
  motor
  eye
  mouth

where we'd reuse motor/eye/mouth on both sides of
the brain, with corresponding body side meanings.

we could send length 2 signals, with left or right
going first, then we'd peel that off and m/e/m
would appear, and we'd follow that gradient to the
(likely) appropriate terminalias.

Now, Signal has 28 bits unused so we could to
two-step routing in a signal atom.. not as cool,
but faster.
[137:

Wed Mar 27 04:59:35 2024 I guess PDSearcher is the
modern FreeWorm-based approach - that currently
has 28 bits available also..

[138:

Wed Mar 27 05:01:09 2024 Could you just drive
until (say) the left gradient was larger than the
right gradient, and then immediately start to
route based on the next component? Seems too good
to be true geometrically - I mean if we want to
allow some slop on the positions of specific
terminals, why would we want to assume they're all
perfectly hierarchically nested wrt sagittal
plane?

buut if we said follow the second as long as the
first wins too, how could we go indefinitely
wrong? We'd never get closer to the right than the
left..

[139:

Wed Mar 27 11:21:50 2024 So how about an 'actual
planned' layout for terminals?


       +---------++---------+
       |SLFL     ||SRFL     |
       |SLFR     ||SRFR     |
       |SLFY     ||SRFY     |
       +---------++---------+
  +---------++---------++---------+
  |         ||  BVREQ  ||         |
  |        L||         ||R        |
  |         ||  BVACT1 ||         |
  +---------++---------++---------+
        +---------++---------+
        |MLRF2    ||MRRF3    |
        |EYEL4    ||EYER5    |
        |         ||         |
        +---------++---------+

[140:

Wed Mar 27 12:02:45 2024 Feels like the
'refactoring' means I'd really prefer to have 2D
coords for localspace rather than hop counts..

Could we just whip that up here? Still go for the
diamond, for now, although rectangle would then be
easy too..

:140]


:139]
:138]

:137]
:136]
[141:

Wed Mar 27 23:53:24 2024 Getting there. A
challenge with 2D coords is that somebody who
'looks' closer to the root -- in terms of inferred
hops -- must be ignored if their position relative
to us implies that WE are closer to the root than
them.[142:

Thu Mar 28 01:13:01 2024 OK that looks better. Had
to rehack the root drift a bit though.

:142]

:141]
[146:

Thu Mar 28 01:15:16 2024 OK let's step out some
plans.

TODO
 - Spike terminal layout in LocalSpace2D, leaning
   on now-existing left and right and forward and
   aft
[148: Thu Mar 28 16:08:42 2024 ended up with 7, but
DONE :148] - Mod LocalSpace2D to carry K (==8?) gradients
 - Assign gradients to motors
 - Could we rebuild PDAnchors within the single
   grid whenever the mind changes? And let the
   signals propagate in order through them?[147:
   Thu Mar 28 10:33:20 2024
 - Find some bits in localspace2D to carry current
   grip info? Let's try it. Maybe 4 bits anyway?


:147]

:146]
[149:

Thu Mar 28 16:39:10 2024 We need a generic
gradient following mechanism pronto. And it needs
some kind of config or virtual to determine which
coordinate( zone)s it likes and dislikes.
[150:

Thu Mar 28 16:49:13 2024 I need a more specific
use case, here.

 - We're going to deploy Terminaliases in the
   LS2D. Separate atoms, tagged by their tag or
   type or some combination (hmm, unclarity #1)

 - In mfms we'll deploy them by hand? In mfmt2
   we'll deploy them how?

   = In both cases have the root issue
     Coord-targeted 'searchers' that go to where
     they're told and then start looking for a
     signal. In mfms they'll find it immediately
     since terminal tile localization is all fake
     there anyway. In mfmt2 they'll rattle around
     until they find a signal coming up through
     the floor?

   = At which point there's a grip being broadcast
     by the root, and terminals will start
     transforming and propagating signals along
     the gradients as implied by the grip.

:150]

:149]
[151:

Thu Mar 28 21:29:25 2024 REMINDERS:
Beevee >>MFMS<< SETUP

(1) Root window to PyBullettime/scripts
    # ./RootWire.sh

    (sets up /mnt/T2TMP and runs socat
    [154: Fri Mar 29 01:26:54 2024 [185:

After rebooting it now appears to be /dev/pts/4
and /5. Looks like you have to look at the socat
output and then reconfigure both[612: Tue Sep 17
16:56:24 2024 (Now PyBulletTime/cfg/Makevars.mk)  :612]

       PyBulletTime/Makefile : DEBUG_DEV

with the lower pts number, and

       apps/sercon/mfmsserloopRunner.sh : SERDEV

with the higher pts number.

:185]
    to connect /dev/pts/30 (PyBulletTime) and
    /dev/pts/31 (mfms) :154]

    [152: [155: NOT ttySXX anymore :155]Fri Mar
    29 00:17:17 2024 Actually NOT ANYMORE NOW IT'S
    /dev/ttyS98 (for the PyBulletTime side) and
    /dev/ttyS99 (for the mfms side) gah :152])

(2) Me window to PyBulletTime
    $ make debug
    (runs sim with IO through /dev/pts)

(3) Me window to T2-12/base/apps/sercon
    $ ./mfmsserloopRunner.sh
    (moves IO between /dev/pts and /mnt/T2TMP)

(4) mfms runs code (like BVBrain.ulam) that
     deploys/uses BVBrainStem and calls methods
     like BVBrainStem.open() and stuff
    (performing IO from and to /mnt/T2TMP)

[153:

Fri Mar 29 00:20:42 2024 OK, ugh, gah, barf. So
apparently the reason to want to use /dev/pts/XX
is so that open connections remain open.. But
using /dev/pts/10 and /dev/pts/11 wasn't working..

So now we're still switched to /dev/ttyS98 & S99,
but we're referring to them as /dev/pts/30 & 31,
for reasons I absolutely do not understand.

But, endless horrible story short, we now have the
spine working again, from pybullet to mfms and
back.

:153]
:151]
[156:

Fri Mar 29 01:29:05 2024 So, our reconstructed
spine is currently topped by a BVBrain - the one
atom hardcoded BV routing. We want to switch back
to using the TermSensor's and TermMotor's in
Terminalias.ulam.

:156]
[157:

Fri Mar 29 08:51:06 2024 Possible locations for
stuff in SpikeLocalSpace2D

root (0,0)
left sense (-9,-9)+-(2,2)
right sense (9,-9)+-(2,2)
left proc (-18,0)+-(2,2)
right proc (18,0)+-(2,2)
left mot (-9,9)+-(2,2)
right mot (9,9)+-(2,2)

[158:

Fri Mar 29 09:04:28 2024 Or..

l/r s/m (+-9,+-10)+-(1,1)
l/r mid (+-18,0)+-(1,1)
[160:

Fri Mar 29 16:45:32 2024 OK let's formalize that
against sm17.toml defns.

"SUPR" lsens (-10,-11)
"SUPY" lsens (-9,-11)

"SLFR" lsens (-10,-9)
"SLFY" lsens (-9,-9)

"SRFR" rsens (+10,-9)
"SRFY" rsens (+9,-9)

"MLRF" lmot (-10, +9)
"MRRF" rmot (+10, +9)

:160]
[159:

Fri Mar 29 09:08:52 2024 So we could be having a
seed that expands into delivery atoms with
hardcoded dests and classids to make.

:159]

:158]

:157]
[161:

Fri Mar 29 22:04:43 2024 OK we apparently have
various terminaliases getting positioned and
deployed within a SpikeLocal2D diamond. Now we
need to get the gradients hooked up.
[162:

Fri Mar 29 23:01:28 2024 OK, possibly have
gradient propagation in LocalSpace2D, but we're
never noticing the Terminaliases so we have no
roots to get the gradients going.
[163:

Sat Mar 30 08:21:00 2024 So Beevee's been running
for a few hours now with this brain layout:

  //                                              SUPR SUPY SLFR SLFY SRFR SRFY MLRF MRRF
  constant C2D.Coord cTARGET_DESTS_X[cTARGETS] = { -11, +11, -11, -10, +11, +11, -11, +11 };
  constant C2D.Coord cTARGET_DESTS_Y[cTARGETS] = { -12, -12, -11, -11, -11, -11, +11, +11 };

and the lag is so much that Beevee's overdriving
and oscillating a rather lot. I'm letting it run
for now - it could make good adventure part I
stuff - but we need a comparatively better layout.

[164:

Sat Mar 30 08:31:42 2024 How about saying the
signals should typically need to cross only one
ITC? Something like:

       +---------++---------+
       |         ||         |
       |     S S || S S     |
       |      S  ||  S      |
       +---------++---------+
  +---------++---------++---------+
  |         ||         ||         |
  |         ||  M   M  ||         |
  |         ||         ||         |
  +---------++---------++---------+

although obviously something more like

       +---------++---------+
       |         ||         |
       |         ||         |
       |         ||         |
       +---------++---------+
  +---------++---------++---------+
  |         || SSS SSS ||         |
  |         ||         ||         |
  |         ||  M   M  ||         |
  +---------++---------++---------+

would obviously be much better still, for response
time. I've been avoiding that because it seems so
unscalably lame, but I think I should be thinking
that that's just plain reality and I should
embrace it. All around that switching nexus would
be 'higher order' stuff to evaluate the larger
scale situation and reconfigure the switching
nexus as appropriately.
[165:

Sat Mar 30 08:50:54 2024 With current stuff though
I think it might be better to think like:

  +---------++---------++---------+
  |         || SSS SSS ||         |
  |     M   ||         ||  M      |
  |         ||         ||         |
  +---------++---------++---------+

because the motors just soak up every signal that
gets close enough to them.. so we don't want
signals passing too close to the wrong motor.

[166:

Sat Mar 30 08:55:31 2024 Maybe perhaps like:

'safe' region (to probably avoid ITCs)
x 0+-5
y 0+-2
          SUPR SUPY SLFR SLFY SRFR SRFY MLRF MRRF
  _X[] = {  +0,  +0,  -3,  -4,  +3,  +4, -13, +13 };
  _Y[] = {  +0,  -2,  -1,  +0,  -1,  +0,  +2,  +2 };

which puts all the 'important' sensors on one
tile, and the main motors both one tile away on
either side - and slightly below, but not so far
as to run into south ITC stuff. At least
theoretically, assuming the seed is placed
precisely (which we can't even do, at present, on
the T2s).
[167:

Sat Mar 30 16:33:53 2024 OK, that's boring to
watch running but it way reduces the overcontrol.
Let's try a few tweaks.

          SUPR SUPY SLFR SLFY SRFR SRFY MLRF MRRF
  _X[] = {  +0,  +0,  -3,  -4,  +3,  +4, -13, +13 };
  _Y[] = {  +0,  -2,  -1,  +0,  -1,  +0,  +2,  +2 };

[168:

Sat Mar 30 21:04:33 2024 OK, that's a lot more
tolerable - about where we were last time, I think
- but let's try to get it even tighter.

          SUPR SUPY SLFR SLFY SRFR SRFY MLRF MRRF
  _X[] = {  +0,  +0,  -2,  -3,  +2,  +3,  -6,  +6 };
  _Y[] = {  -1,  -2,  -1,  +0,  -1,  +0,  +2,  +2 };

:168]
:167]
:166]

:165]
:164]

:163]

:162]

:161]
[169:

Sun Mar 31 02:03:30 2024 OK time time time.

So can we demo a mind change? Switch to red avoid?
What would that routing be?

have red inhibit opposite wheel?

Just that? Nothing that actually excites the
motors?

have the motors default to slightly excited, and
red cross inhibit?

[170:

Sun Mar 31 02:07:29 2024 OK, well, something like
that maybe. Two questions:

(1) How would we implement that all on its own?
(2) How do we switch to it from the default
    strategy?

[171:

Sun Mar 31 02:13:39 2024 Seems like one main key
is TermSensor.getGradIdxToFollow() which performs
'source routing' of sensor signals. We're going to
modify that to take a 'Mind' or 'Mind&' parm,
maybe? So when the mind changes the routing can
change? It's a double dispatch situation of
course. Actually it should probably be Grip&,
given our general terminology.

What's the bit budget in SpikeLocalSpace2D these
days? [172:

Sun Mar 31 02:43:35 2024 9 available.
[174:

Sun Mar 31 03:34:04 2024 So, shall we invent a
Grip? We don't have one yet, right?[175:

Sun Mar 31 05:23:13 2024 OK so we made Grip.ulam
and threaded it into Terminalias at least.

Went with four Grip bits for 16 possible 'minds'
to change to.

:175]

:174]
But we seem to have a healing failure in the
diamond after an inadvertent ^X.. What's that
about? [173:

Sun Mar 31 03:24:32 2024 Well, not completely
diagnosed, but it looks like the signal gradient
updating was claiming changes for some reason,
which then bypassed healing the grid. Applied
fix was moving the grid healing ahead of the
gradient stabilization.. and things now seem okay
again.

Pop pop pop.

:173]

:172]

:171]

:170]
:169]
[176:

Sun Mar 31 06:07:30 2024 So okay. Almost nap time
but let's push a little more first. Right now our
'default mode' is BV2B-Yellow.

Suppose we made a 'hunt mode'
(1) left motor 25%
(2) right motor 20%
(3) significant yellow => eject mode
(4) significant red => avoid mode

eject mode
(1) left front yellow -> right motor
(2) right front yellow -> left motor
(3) significant red => avoid mode

we need a 'grip motor' that we can route signals
to. we'd need a 'grip sensor' to emit new grips,
but for now we're going to broadcast that through
the grid.

:176]
[177:

Sun Mar 31 10:31:11 2024 Made GRIP : TermMotor.
Can we route say Red to it, in the default grip?
[178:

Sun Mar 31 11:07:16 2024 Well, can we tweak the
layout again so that we could put the GRIP at
(0,0)? Would make issuing grip changes easier.

[179:

Sun Mar 31 11:29:32 2024 maybe move SUPR and SUPR
to the bottom, and raise everything else up?

  //                                              SUPR SUPY SLFR SLFY SRFR SRFY MLRF MRRF GRIP
  constant C2D.Coord cTARGET_DESTS_X[cTARGETS] = {  -1,  +1,  -2,  -3,  +2,  +3,  -6,  +6, +0 };
  constant C2D.Coord cTARGET_DESTS_Y[cTARGETS] = {  +3,  +3,  -3,  -2,  -3,  -2,  +1,  +1, +0 };

[180:

Sun Mar 31 11:53:13 2024 Well maybe I want to
raise (0,0) toward tile top, and push everything
else below it (to +ve Y).. with the current GRIP
position an awful lot of signals meant for the
'real' motors are passing by the GRIP..

  //                                              SUPR SUPY SLFR SLFY SRFR SRFY MLRF MRRF GRIP
  constant C2D.Coord cTARGET_DESTS_X[cTARGETS] = {  -1,  +1,  -2,  -3,  +2,  +3,  -6Z  +6, +0 };
  constant C2D.Coord cTARGET_DESTS_Y[cTARGETS] = {  +5,  +5,  +0,  +1,  +0,  +1,  +4,  +4, +0 };

:180]

:179]
:178]
:177]
[181:

Sun Mar 31 17:26:12 2024 Well I had some stupid
bugs that were I think significantly slowing down
signal propagation, so things might not be as bad
as they looked lately as far as needing to get the
S<->M paths super short.[182:

Sun Mar 31 17:52:11 2024 Looks like maybe if the
running average red exceeds maybe 15, Beevee might
want to change its mind.

:182]

:181]
[183:

Mon Apr  1 01:39:01 2024 SO okay, I think we have
the grip value broadcasting down from the root. So
I think we need two things:

(1) Some kind of GripInfo API where we can
    consolidate routing information for the
    terminaliases
(2) Well let's start with that.
[184:

Mon Apr  1 02:56:52 2024 OK well made a ton of
stuff - GripInfo, GripInfoMap - and it builds but
it's untested so far. And we have

    quark BV2BYGripInfo : GripInfo { // BV2B on Yellow
      @Override String getGripName() { return "BV2BY"; }
      @Override ClassId getDestination(ClassId sensid) {
        which (sensid) {
          case SLFY.classidof: { return MRRF.classidof; }
          case SRFY.classidof: { return MLRF.classidof; }
          case SLFR.classidof: { return GRIP.classidof; }
          case SRFR.classidof: { return GRIP.classidof; }
        }
        return 0u;
      }
    }

as currently the only implemented GripInfo. We
still need to have things like TermSensor.behave()
determine the current grip from the neighboring
LocalSpace2D, and then apply it..

:184]

:183]
[186:

Mon Apr  1 16:27:46 2024 OK, we are totally
totally out of hacking time, here... so... how do
we have GRIP decide when to change its mind? Does
GripInfo have that? It should, yes?[187:

Mon Apr  1 17:14:36 2024 Taking a tea break. Need
GRIP to call GripInfo.getNextGripNumber and do
something appropriate..

:187]

:186]
[188:

Mon Apr  1 21:33:23 2024 OK how is NoRedGrip
supposed to work? In particular, how is the grip
supposed to know when to exit NoRedGrip? We're
sending red to the motors, not to GRIP, so GRIP
can't tell when there's no more red. We really
need mechanism to send the same signals to
multiple destinations, but we have no
infrastructure for that.

Hmmmmm. What if we randomly sent some signals to
the motors and some to the GRIP? GAAAH WHAT A
HACK.

:188]
[189:

Mon Apr  1 22:34:18 2024 Need to move SxFY lower
and/or wider to avoid occasional captures by GRIP
(at least when GRIP ends up S of LS root, and SxFY
ends up N of its LS).

:189]
[190:

Thu Apr  4 08:23:26 2024 (Copied in..)

HACK:
 - 'myelination' for signal speed DO IT DO IT
 - multiple destinations per signal?
 - hidden unit oscillator
 - self-stabilizing
 - phase-locking tempo adjustment
   =
 - local gradients
[196: Thu Apr 11 07:06:47 2024 took forever but
DONE :196] - real time on merge videos

:190]
[191:

Fri Apr  5 07:23:19 2024 OK, maybe some more
specific steps for myelination..
[194: Fri Apr  5 08:18:58 2024 started anyway
DONE :194] - Make Myelin.ulam
[195: Fri Apr  5 08:19:07 2024 not really tested but
DONE :195] - Generalize Seg.ulam to handle non-ew[0] centers
 - Have Myelin search for FreeWormM and use Seg to
   help it along.

( Another 'standard' efficiency: If we are a temp,
and are between an end and another temp, we can
delete ourselves (if not too stretched) (Or
actually this may already happen simply on
pairwise bases ) )

  :191]
[192:

Fri Apr  5 07:43:05 2024 So, how much does
Seg.ulam actually do, at the moment?[193:

Fri Apr  5 07:52:45 2024 Maybe have Myelin point
toward the FW they think they're helping? So FWMs
could distinguish between 'their' myelin and those
of other FWMs nearby? Allow us to adjust into our
myelin but not other's myelin, help avoid
tangling?

:193]

:192]
[197:

Thu Apr 11 07:07:11 2024 More stuff

 - Redo motor signalling to be (in effect) signed,
   for bidirectional wheels.

And how are we going to do that? Just have the
sensor terminals do it as part of their mapping,
before shipping signals toward the motors? Plus
have motor.py or whatever interpret the signals
that way.

But we're not actually going to do signed bytes on
the wire.[198:

Thu Apr 11 08:29:19 2024 OK so maybe we
conceivably have signed motor values going. So far
only BV2B is using the format, though, and it
doesn't do reverse, so..

But my next question is: How do we USE reverse? If
we just back up on red, for example, won't we just
get to a metastable point and start jiggling back
and forth, or something like that?

:198]

:197]
[199:

Thu Apr 11 15:25:54 2024 So okay. I want to push
on 'h/w' changes for Beevee, before it's too late
for such a struggle. Specifically:

 - left and right 'eyestalks' aligned with l&r
   camera views
 - camera fully locked to body (eyestalks) instead
   of floating above it
 - chain of tiny objects to represent mouth? too
   silly, I know, but..
   = with maybe four degrees of freedom
     - left x, right x : how far from center is anchor
     - left angle, right angle : which way do
       segments want to bend

[200:

Thu Apr 11 15:31:04 2024 Let's stick to the
eyestalks for now.

TODO
[206: Sun Apr 21 02:01:53 2024
DONE :206] - Review how to modify Beevee's body
[207:
DONE :207] - Add a cylinder and a sphere as eyestalk?
[208:
DONE :208] - Add a revolute joint at the bottom
[209:
DONE :209] - Position two of them automatically
[210:
DONE :210] - Have them swivel about randomly
[211: Sun Apr 21 02:02:21 2024
DONE :211] - Laugh at the results
 - Make more to-do

:200]

:199]
[201:

Thu Apr 11 15:37:21 2024 OK,
PyBulletTime/scripts/makeTestRobot.pl generates
genrobot.urdf. Let's wander in the .pl for a
moment. [202:

Thu Apr 11 15:38:38 2024 OK, the .pl is primarily
a giant here-doc string print, parametrized for
sizes and masses, mostly, it looks like.

So we ought to be able to add a cylinder and a
sphere.
[203:

Sat Apr 13 10:20:36 2024 Well, we added a couple
'stalks' and managed to get them plausibly
positioned, but we've been super struggling to get
the camera views to 'look from' the stalks.

Finally found some plausible looking code last
night -
https://github.com/bulletphysics/bullet3/issues/1616
- and maybe we're now in the same county as the
ballpark.

Now going to add some kind of fixed join 'eyeball'
on top of the stalks, primarily so we can see
which way the stalks are actually oriented.. Maybe
use a cuboid rather than a sphere, to make
rotation motions more obvious..[204:

Sun Apr 14 09:57:24 2024 Well, made 'eyeboxes'
rather than 'eyeballs' but that's starting to look
plausible. Now have the eye stalks swiveling (under
direct h/w control for now) and the resulting
sensor images look plausible - all the way down to
the eyes seeing each other at the limits of their
swivels..

Now we need some kind of pupil/iris thing, so the
eyeboxes read properly at a glance, and then we
need redo the spine and brain to start passing
more stuff!

:204]

:203]

:202]

:201]
[205:

Sun Apr 21 02:00:59 2024 A week? A WEEK? With no
notes? Oh man that's pitiful.

[212:

Sun Apr 21 02:02:43 2024 Well at least we could
claim some to-dos.

I confess I'm still wondering about Beevee's mouth
though. It seemed like the 'deformable soft body'
stuff in PyBullet might be a way to go, but I
didn't have much luck getting an example working
or figuring out how to generate an appropriate
file given my laimo skilz.

Maybe take one last 'quick' run at that? I have to
switch back to the Onward essay in not that many
hours here.

:212]

:205]
[213:

Sun Apr 21 10:10:04 2024 OK, I think I've been
defeated by loadSoftBody and the apparent need to
have both an .obj and a .vtk file to feed it. I've
installed VTK and Gmsh and whatever whatever, but
only reached the point where I'd now need a STEP
file as input and I've had enough.

What about making a mouth out of a bunch of rigid
cylinders? Couldn't I generate like a chain of
pairs of links separated by alternate revolute and
sliding joints? Hohoho how hard could it be?

:213]
[214:

Wed May  1 11:14:10 2024 Well it looks like we
have two 'mouth corners' getting generated.. Can
we 'real quick' go for a 'lip chain' between them?
[215:

Wed May  1 11:19:31 2024 Hmmm. How can we have a
chain attach to both mouthcorners without
violating the 'every link has one parent' rule?
Muh moh.[216:

Wed May  1 11:31:51 2024 Apparently we use some
kind of 'constraint' to close the loop rather than
a joint.

:216]

:215]

:214]

[217:

Wed May  1 22:43:12 2024 Well thinking I need to
get into Beevee's brain a lot more than I need to
get into his mouth. So to speak. We've got serious
brain to-do to do right.
[218:

Wed May  1 22:44:19 2024 Well let's say:

TODO
 - Review signal releasing system.
 - Come back here and summarize the results
 - Come up with a way to release multiple signals
   per spinal report. At least up to two!
 - Implement that
 - Fix the case where one terminal is randomly
   sending to one of two dests so it sends to
   both.
 - Come make more to-do.

:218]
:217]
[219:

Wed May  1 22:49:27 2024 Info about current
routing is stored in GripInfo.
[220:

Wed May  1 22:51:39 2024 Which is (all) virtual..
Using an API with stuff like:

  virtual String getGripName() ;
  virtual ClassId getDestination(ClassId forSensor) ;
  virtual Unsigned getNextGripNumber(GRIP& grip) ;

where that getDestination() return value limits us
to a single destination.[221:

Wed May  1 22:57:16 2024 So like The Obvious (TM)
extension would be:

  virtual Unsigned getDestinationCount(ClassId forSensor) ;
  virtual ClassId getDestination(ClassId forSensor, Unsigned index) ;

and let caller decide what to do about
getDestinationCount(..) == 50u or whatever.

And how would callee implement the API?[222:

Wed May  1 23:03:00 2024 Callees are subclasses of
GripInfo, such as BV2BYGripInfo. It's all just
code.

In particular, NoRedGripInfo is (the) one that
uses random to dispatch to two targets. This looks
straightforward to revise. What about caller?[223:

Wed May  1 23:05:39 2024 Well for starters,
TermSensor uses getDestination(..) to power
getGradIdxToFollow(GripInfo &), and
TermSensor.behave() calls getGradIdxToFollow. That
would all need to be cleaned up to iterate over
destination indicies.
[224:

Wed May  1 23:11:31 2024 Now, I'm not sure how
much code we have that uses it (yet, if any), but
we did extend XPick to save all the qualifying
hits it finds. So we ought to be able to iterate
over, say, Emptys, and fill them with signals, if
we wanted.

(Not sure we have a way to randomize the returns,
though.. They're collected in iteration order.)
[225:

Wed May  1 23:54:52 2024 Well, made
XPick.getFoundIndexCount() and
XPick.nextFoundIndexRandom() that theoretically
means we can iterate over the found indicies in a
random order.

:225]

:224]
:223]

:222]

:221]

:220]
:219]
[226:

Thu May  2 11:35:52 2024 OK. So we have,
apparently, seven gradients to work with in
SpikeLocalSpace2D10, which in turn has 7 unused
bits remaining. Right now, it looks like we're
using four gradients --
  constant ClassId cCLASSIDS_OF_GRADIENTS[] = {
    BVACT.classidof,
    MRRF.classidof,
    MLRF.classidof,
    GRIP.classidof
  };

-- leaving three more to work with. How shall we
spend them?[227:

Thu May  2 11:50:16 2024 Could we use just one for
one end of a RingO oscillator, and use GRIP for
the other end?

It really does feel, though, like we're
super cramped for destinations. We'd fantasized
about having routable motor controls for:

 - Tick and Tock
 - Left and right eye rotations
 - Left and right mouth corner rotations

in addition to what we have now.

(We don't really need to dedicate a gradient to
BVACT, though; that could buy us one back.)

[228:

Thu May  2 12:15:57 2024 Now possibly, if we
wanted, we could tie the eyes together and control
both with a single rotation. But that's not as fun
- and we couldn't then do vergence on targets.

0. GRIP
1. MRRF
2. MLRF
3. MLEY
4. MREY
5. MLMC
6. MRMC

It's really really silly to do the mouthcorners at
this point, with this flat routing design.. and we
haven't allocated a clock yet..

0. MRRF
1. MLRF
2. MLEY
3. MREY
4. GRIP
5. TOCK
6.  --

[229:

Thu May  2 12:36:28 2024 Well maybe possibly? Can
we get to implementability here? Let's replace
BVACT with TOCK and see if we can deploy a TOCK.
[230:

Thu May  2 13:24:29 2024 OK so what signal are
TOCK (and GRIP) going to send each other? [231:

Thu May  2 13:33:13 2024 Iiiiii guess they just
send Signals, literally, and use the mSourceSignal
to see who it's from.

:231]

:230]

:229]

:228]

:227]

:226]
[232:

Fri May  3 08:34:43 2024 So okay, we have a TOCK
ticking about 2-3Hz now, and we need to route it
somewhere. What does TOCK have to do to implement
GripInfo mappings?[233:

Fri May  3 09:46:10 2024 So it seems kind of a
mess (such a shock) because the basic 'emitting
signals' code all assumes the spine has just
ticked and we're creating a signal to respond to
that. 'Hidden units' like GRIP and TOCK have to do
it manually, if they want to, it appears..

Well so let's try to do it. Can we TOCK to
somebody when we're in hunter mode, say?[234:

Fri May  3 16:02:51 2024 OK, so, well, we finally
have NORED actually backing up when it sees red.
After fixing a longstanding stupid bug I finally
saw, where we max(0,..)'d away all negative motor
values..

Now we really really need a way to send autonomous
motor signals, to get Beevee to move in the HUNTR
grip.[235:

Fri May  3 16:08:14 2024 Could we have TOCK check
the grip, and just send signals if we're in HUNTR?
Like send to MLRF/MRRF when tock is on and send to
the eyestalks when tock is off?

[236:

Fri May  3 16:12:38 2024 But the eyestalk joints
aren't even represented in the .toml yet? What's
that stuff in :228: above going on about?

:236]

:235]

:234]

:233]

:232]
[237:

Fri May  3 23:22:31 2024 We should screw the
eyestalks for now and focus on getting Beevee to
move while in HUNTR grip.
[238:

Fri May  3 23:24:12 2024

TODO
[240: Sat May  4 03:46:04 2024
DONE :240] - Review how to determine the current grip
[241:
DONE :241] - Ensure TOCK can do that
[242:
DONE :242] - Have TOCK send constant signals to MLRF/MRRF
[243: Kind of - just based on mUsState
DONE :243] - Have TOCK send varying signals based on its statecount
 - Set up a special starting mode that puts Beevee
   far from the balls?

:238]
:237]
[239:

Fri May  3 23:35:41 2024

Unsigned Terminalias.updateGripNumber(..) returns
the current grip (or Unsigned.maxof if it can't
determine the grip).

:239]
[244:

Sat May  4 03:46:44 2024 OK so TOCK is sending
motor commands in the HUNTR grip. Just changed it
to switch directions based on mUsState.. too soon
yet to see what effect that may have. Also
increased TOCK's distance to +23 in another
attempt to slow it down a bit more. But that just
puts in the middle of a tile and so probably won't
gain much time over the +21 we were doing before.

:244]
[245:

Sun May  5 03:16:01 2024 OK really running out of
time here now. But we've got a 'hero cam' shot of
Beevee now in the lower left corner and that
amuses me. (And if we ever get the eyes
articulating we'll see that best in the hero cam.)

:245]
[246:

Mon May 13 02:10:47 2024 OK so now we're running
Beevee's brain on a small (portable) collection of
T2 tiles, and it's well past time to start
figuring out how to clear ALL the yellow balls.

Which I imagine will involve some combination of

1 - having each eyestalk autotrack a color
    selected by the current grip. That will
    involve the 'half-sensors' that we've already
    built into each eye, and servoing the stalk to
    try to reduce the difference in the
    half-sensors to zero.

2 - having each eyestalk settle in its 'default'
    position or auto-rove depending on the grip

3 - can we figure a way to have the eyestalk
    angle modulate sensor-to-motor signals? Like,
    eyestalk angles closer to the currently
    targeted position should have more influence?

[247:

Mon May 13 03:36:26 2024 How to we do these
things? Issues include:

 - Limited number of motor gradients, most of
   which are already used.

What's the exact status of that, anyway?[248:

Mon May 13 03:39:27 2024 Well, the LocalSpace2DT
template

  quark LocalSpace2DT(Unsigned cBITS,Unsigned cTAGBITS,Unsigned cGRIPBITS, Unsigned cGRADBITS, Unsigned cGRADS) : LocalSpace2D

has a parameter cGRADS which determines the number
of gradients, and a parameter cGRADBITS which
determines the bitcount and thus the range of each
gradient.

And then we have

    element SpikeLocalSpace2D10 : LocalSpace2DT(6u,3u,4u,6u,7u)

which is the LocalSpace2D variant we are building
with. So, seven gradients, six bits each.[249:

Mon May 13 03:48:02 2024 Right now, we've declared
five of the seven gradients in Terminalias:

  constant Unsigned cGRADIDX_TOCK = 0u;
  constant Unsigned cGRADIDX_MRRF = 1u;
  constant Unsigned cGRADIDX_MLRF = 2u;
  constant Unsigned cGRADIDX_GRIP = 3u;
  constant Unsigned cGRADIDX_MEYS = 4u;

where 'MEYS' is a so-far unimplemented hack that
was meant to drive both eyestalks via a single
motor controller. But with our auto-tracking
business if we're at all serious about that, we'd
like separate stalk control.

Which would mean we're at six of seven gradients
used - and that's without considering additional
hidden state units that we will almost surely want
to have and route to.[250:

Mon May 13 03:54:05 2024 If we cut back to five
bit gradients we could have eight of them and
still save two bits..  How full is
SpikeLocalSpace2D10, anyway? Pretty full I
bet. [251:

Mon May 13 03:55:46 2024 Currently it's:

      /*__________________________________________________
      | COMPONENTS of SpikeLocalSpace2D10 <89> (64 bits/7 unused):
      |
      | Pos	| Bits	| Name	| Type <classid>
      | 0	| 61	| super	| LocalSpace2DT(6u,3u,4u,6u,7u) <88>
      | 61	| 0	| base	| UrSelf <0>
      | 61	| 0	| base	| DTU <40>
      | 61	| 0	| base	| Intender <85>
      | 61	| 0	| base	| LocalSpace2D <72>
      | 61	| 3	| base	| QDebugUtils <21>
      | 64	| 0	| base	| Fail <43>
      |___________________________________________________

so we could have nine by five I expect. Could we
have 8 x 6? We're going to run into the 64-bit
quark limit, I think..
[252:

Mon May 13 04:03:29 2024 Yeah:

    ./LocalSpace2D.ulam:52:7: ERROR: Trying to exceed allotted bit size (64) for quark LocalSpace2DT(6u,3u,4u,6u,8u) with 70 bits.
    ./LocalSpace2D.ulam:52:7: NOTE: Components of LocalSpace2DT(6u,3u,4u,6u,8u) are..
    ./LocalSpace2D.ulam:78:3: NOTE: (6 of 70 bits, at 0) Int(6) mPosX.
    ./LocalSpace2D.ulam:79:3: NOTE: (6 of 70 bits, at 6) Int(6) mPosY.
    ./LocalSpace2D.ulam:82:3: NOTE: (48 of 70 bits, at 12) GradientStgT(6u) mOurGradients[8].
    ./LocalSpace2D.ulam:84:3: NOTE: (3 of 70 bits, at 60) Unsigned(3) mTag.
    ./LocalSpace2D.ulam:86:3: NOTE: (4 of 70 bits, at 63) GripStgT(4u) mLocalSpace2DGrip.
    ./LocalSpace2D.ulam:1:7: NOTE: (0 of 70 bits, at 67) from super base class: LocalSpace2D.
    ./DTU.ulam:4:7: NOTE: (0 of 70 bits, at 67) from shared base: DTU.
    ./Intender.ulam:1:7: NOTE: (0 of 70 bits, at 67) from shared base: Intender.
    ./QDebugUtils.ulam:1:7: NOTE: (3 of 70 bits, at 67) from shared base: QDebugUtils.

If we virtualized mPosX/Y into the element, we
could do it.

[253:

Mon May 13 04:05:21 2024 Well yug. How many
gradients do we really want, to pull this home in
say three more weeks?

  constant Unsigned cGRADIDX_TOCK = 0u;
  constant Unsigned cGRADIDX_MRRF = 1u;
  constant Unsigned cGRADIDX_MLRF = 2u;
  constant Unsigned cGRADIDX_GRIP = 3u;
  constant Unsigned cGRADIDX_MESL = 4u;
  constant Unsigned cGRADIDX_MESR = 5u;

at one point we fantasized about two motors for
Beevee's mouth, hohoho. But we're going to need
more internal state, right?

How do we servo the eyestalks?

1 - They have a FixMax internal desired angle that
    they'll feed to the spine.

2 - The half-sensors (e.g., SLLY 'Left Left-side
    Yellow detector' and SLRY 'Left Right-side
    Yellow detector') will (read the GRIP and)
    both feed to the corresponding eyestalk (e.g.,
    MESL), which will apply them incrementally to
    the internal desired angle.

3 - The internal desired angle, in turn, will feed
    to what, in addition to the spine? To the
    wheels? To the associated 'full frame'
    sensors? Do we even need the full frame
    sensors?

[254:

Mon May 13 04:49:39 2024 Let's pop up the stack a
bit and review the GRIP behaviors we want.

HUNTR:
 - Set eyestalks wide, tracking yellow
 - Do run-n-tumble.
 - Turn toward yellow if you see it
 - If yellow > Y, switch to DRIVE
 - If red > R, switch to NORED

NORED:
 - Set eyestalks forward
 - Back away from red until see very little red
 - If red < R, switch to HUNTR

DRIVE:
 - Set eyestalks forward
 - Head towards yellow
 - If red > R, switch to NORED
 - If yellow < Y, switch to HUNTR

[255:

Mon May 13 10:20:10 2024 Well that might be
plausible, as far as it goes. How might we do run
and tumble?

The challenge mostly seems to be about how we want
to do the timing. If we just put a counter in an
atom, with a random component, well then no
problem, but it's not very satisfying.

..what about if we had a bunch of atoms acting as
roots for the same gradient, so there could be
multiple equivalent destinations and we could make
something like a Galton board out of the spatial
grid between them? Then depending on which one
gets the signal, different things can happen.


    left  run   left   run    right  run   right
    long  long  short  short  short  long  long
 (tumble) (run)                     (run) (tumble)

..or just
               left  run  right
               spin  long spin


[256:

Mon May 13 10:49:27 2024 Another fun thing to
think about might be a "double Galton" board,
where there's a row of sources as well as
destinations.

               act    act     act

             left   straight   right

so the various spatially distinct but otherwise
equivalent 'act' terminals provide additional
state, making direct transitions from spin left to
spin right, say, much less likely.

[257:

Mon May 13 10:55:16 2024 I'd kind of like to spike
that. [258:

Mon May 13 11:05:30 2024 Actually, maybe we should
go for per-grip fixed eyestalk control, as a more
immediate goal.

TODO
[260:
DONE :260] - Commit changes from keymaster
[261:
DONE :261] - Pull to nubiga
[269: Tue May 14 03:01:20 2024 kind of anyway
DONE :269] - Review needs for adding motors to grid
 - Review signal conditioning
[270: Tue May 14 03:01:35 2024 MLEY and NREY
DONE :270] - Create MESL and MESR Terminaliases
[271:
DONE :271] - Layout MESL and MESR somewhere
 - Make them GRIP sensitive:
   HUNTR: wide
   NORED: forward
   BV2B:  forward
 - Get that working
 - Laugh at stalk angle changes
 - Come make more to-do
( - Like: layout SLLY SLRY SRLR and SRRR? )

:258]

:257]


:256]

:255]
:254]

:253]

:252]

:251]

:250]

:249]


:248]

:247]

:246]
[259:

Mon May 13 11:21:58 2024 OK we're back on nubiga
for now. Claiming those.

I think adding motors to grid has these steps:
 - Declare them in the .toml (already done as MLEY
   and MREY)
 - Ensure at some point that they are hooked up in
   motor.py
 - Declare them in TermTargetLibrary (in
   Seed10.ulam; let's lift that shall we?)


[262:

Mon May 13 11:26:14 2024 So it looks like if we
add MLEY MREY SLLY SLRY SRLR and SRRR, that will
completely exhaust the capacity of our
TermTargetLibrary. Just saying.

:262]

:259]
[263:

Mon May 13 11:53:01 2024 So, what about putting
the half-sensors and the eyestalk angles in a
different tile or tiles????

That would test out a lot of untested stuff, which
is scary but kind of what we signed up for, here..

If the claim is two half-sensors + a stalk motor
is a little module, sensitive only to GRIP..

[264:

Mon May 13 12:08:00 2024 A major challenge to that
at this point, though, is having confidence we can
place stuff at a distance and get it to land on
the intended tile.. I guess we could figure normal
coords for the centers of our desired tiles, and
cluster stuff around them.. Maybe let's try
that.[265:


Mon May 13 12:09:53 2024 T2s appear to be 16
LocalSpace2Ds wide and 11 high? So like 48x32
sites? Probably. So if we went +11 on Y and +/- 8
on X we should be in the meat of the SW and SE
tiles?
[266:

Mon May 13 12:12:43 2024 Aaaand we actually do NOT
have a 43x32 tile in mfms? How can that possibly
be? What if we resized Type 'C' to be 48 x 32
instead of its current 40 x 40? Or maybe Type 'D',
from 54 x 54? Really don't want to add another
size since that will blow out the binary and the
T2 build time even more than it already is.. Or,
does mfmt2 only build 48x32 anyway?[267:

Mon May 13 12:17:49 2024 Actually I think it does
just to that..[268:

Mon May 13 16:08:50 2024 OK, added type A as
56x40 in mfms, which appears to match the T2s
however caches and such are considered.

:268]

:267]

:266]

:265]

:264]

:263]
[272:

Sun May 19 01:46:05 2024 Ohhhhhhhhkay here. We've
got to redo Beevee's HUNTR strategy, which, I
believe, has not once ever found another yellow
ball.[273:

Sun May 19 02:22:55 2024 I want run-n-tumble, and
for that we need at least a longer timer than we
currently have.

I'm wondering: What if we put in two TOCKs, at the
same Y but one +X and one -X of the GRIP? So
theoretically it ought to be 'randomish' whether
TOCKNEG or TOCKPOS would catch the signal from
GRIP. [274:

Sun May 19 02:56:08 2024 Could we actually deploy
two TOCKs? What would they do? Time-out more
often?[275:

Sun May 19 02:58:36 2024 I guess the main problem
is during HUNTR they'd both try to drive the
motors, with potential differing states.

[276:

Sun May 19 02:59:41 2024 What if we just made TOCK
probabilistic? So it was only a jerk a 3rd or a
10th of the time or whatever? Wouldn't that slow
the cycling without actually counting internally?

What if we combined that with actual 'tumbling'
using negative motor speeds?

HUNTR state true: RUN, jerk with odds 1-in-10
HUNTR state false: TUMBLE, jerk with odds 1-in-3

Limitation I guess is it will always tumble in the
same direction - CW or CCW as we choose.
[277:

Sun May 19 03:03:58 2024 Let's try it. At least
let's get something building on the
keymaster.[278:

Sun May 19 04:24:10 2024 Well, went with being a
jerk 1/3 of the time for both run and tumble, and
it's now building on the KM, but now I kind of
wish I'd gone like 1/5 or lower. We shall see.
[279:

Sun May 19 04:30:52 2024 Well, pushed it down to
1/8 because I thought I saw a bug in the logic and
wanted to restart the build anyway.. So we'll see..
[280:

Sun May 19 05:02:49 2024 Build finished![281:

Sun May 19 05:16:14 2024 Beevee and its brain
running! (Well, the brain is still forming, but
Beevee is running, or standing, actually..)
[282:

Sun May 19 09:34:56 2024 So okay took a nap and
the current status is: The slowed-down clock isn't
working because TOCK isn't reissuing signals after
it receives one? So nothing happens then
eventually (TOCK or) GRIP times out and ships
another signal.

That needs to be debugged, but it's not clear how
much it matters in the action so far, since there
hasn't been much hunting.[283:

Sun May 19 09:40:52 2024 Think we need to review
how the GRIP-TOCK RingO was supposed to work. In
particular, there's stuff that's supposed to
collapse multiple signals, and I think that's at
least part of what's messing up the current hack.

TOCK state:

  Bool mUsState;                // Our state
  Bool mThemNotState;           // Opposite of their state last we heard

also has:

  typedef Unsigned(9u) EvtCount;
  EvtCount mStateCount;  // up on mUsState, down on !mUsState

  but it's not clear that anything depends on that.

TOCK color:
  bright green if mUsState
  else dark green.

TOCK behave() processing:
 - scan non-self event window
   = emppick: an empty in the Moore ngb
   = sigpick: any signal from GRIP
     - (also erase all such signals)

[284:

Sun May 19 09:53:16 2024 I think the problem is we
only enter the 'probabilistic jerk' code if the
NOTted-signal value from GRIP is different from
mThemNotState.

And when that's true, we then copy their
not-signal to mThemNotState, so we're set up to
not enter this path again.

Or something like that. It's a fogging mess.

But the bigger picture is that right now, if TOCK
fails to be a jerk, that will look the same (I
think) as if there was a duplicate signal, which
we were trying to collapse out, to avoid getting
double-tempo (or worse) clocking.

So now I'm thinking we actually do want a little
counter, something bigger than one bit anyway, so
we can distinguish rando-or-dupe-to-be-ignored
from next-sequential-signal-from-ourself, and only
respond to the latter, while also sending the
clock signal separate from the count.

Urgh.
[285:

Sun May 19 10:03:28 2024 Aand if we just sent a
three-bit counter (say) we could flip TOCK state
each time the counter turns over. [286:

Sun May 19 10:43:52 2024 But how lame is that?
Just make it a nine bit counter or whatever and
dispense with TOCK entirely.[287:

Sun May 19 22:43:42 2024 Well I'm going to an
internal timer-based TOCK and screw the ring
oscillator. Sigh.
[288:

Mon May 20 00:12:32 2024 OK, well I guess there's
a first cut at an internal timer (again, sigh),
supporting a ridiculous 20 bit counting range.
Let's push it over to the KM and get it building..

:288]

:287]

:286]

:285]
:284]

:283]

:282]
:281]

:280]
:279]
:278]

:277]
:276]

:275]

:274]

:273]

:272]
[289:

Thu May 23 09:38:36 2024 Well, it took a few days
and a few new brains along the way, but Beevee
managed to clear the board last night.

Yay Beevee! You were right! You did it!

[290:

Thu May 23 09:49:07 2024 So one thing that's
bugging me now is we have no camera taking
pictures of Beevee's little portable-matrix brain.

Eventually we need to move all this to the big
matrix, but for the next week or so we really want
a way to shoot the little matrix programmatically.

:290]

:289]
[291:

Sun Jun  9 10:39:15 2024 OK so shameful weeks
passed without any notes here,, but there was
progress. Beevee's brain's running on (a small
corner of) the big matrix and we have mostly but
not completely automated the brain imaging
process.

Today I'm trying to start into tearing up local
space to avoid the hard gradient limit and instead
move toward more programmatic routing that will
support stuff like little crossbars, within
regions of the overall local space.

Currently working in XBarSpace2D.ulam
[292:

Mon Jun 10 01:00:40 2024 OK so mfms mangled name
parsing has an issue with zero length arrays of
classes.. so for now we're leaving one gradient in
there..

So. Now we have XBarSpace2D: How exactly will we
route in it? How are terminals numbered these
days? We were going to have four terminalias (now
called 'tap') settings in each XBarSpace2D, for
NSEW, and that's going to help us route. Signals
will have an 'outgoing' state and an 'incoming'
state, and they switch to incoming when they turn
toward their destination in the switch. (Other
Signal mapping may occur at that time as well.)

We're thinking we'll have a single hardcoded
numbering of all taps? Where is that now?[293:

Mon Jun 10 01:36:38 2024 Well, there's
TermTargetLibrary in TermTaget.ulam that has an
array of all tap names, hidden and visible.[294:

Mon Jun 10 01:38:20 2024 And DeliverTerm has a
'typedef Unsigned(5) TermTargetIdx' (which should
probably really be

 typedef TermTargetLibrary.TargetCount  TermTargetIdx;

but anyway) and it builds a TermTarget which for
some reason has a String mTermName..[295:

Mon Jun 10 01:52:13 2024 And it uses
DTU.getClassIdOfElementNamed(String) to get
something buildable. Which string compares and ALL
FRICKEN DEFINED CLASSES, doh.

[296:

Mon Jun 10 02:58:59 2024 So okay. Let's make
TermTargetLibrary's info be canonical. And go with
Unsigned(5) for TapIdx.[297:

Mon Jun 10 08:48:41 2024 That puts XBarSpace2D at
49 bits/22 free so far. Which isn't too horrible,
though we'll want some kind of return paths for
code and signaling, we imagine..[298:

Mon Jun 10 08:50:44 2024 That's with a Unsigned(4)
for the grip, so we've got relatively plenty of
headroom there.

I guess we're thinking the grip namespace is part
of the programming environment to be defined.

So how about an XBar outputting a one-hot next
grip? We could build in a little systematic
hysteresis if we wanted to.

              +----------------+
              |                |
              |                |
 signals      |                |
         SRFR |                |
         SLFR |                |
         SRFY |                |
         SLFY |                |
              +----------------+
 grips         0  1  2
           avoid  |  |
              pursue |
                  explore

[299:

Mon Jun 10 09:11:12 2024 It's like put the sensors
down the middle and sprout an xbar off of either
side. From one side generate next motor commands,
dependent on grip and state; from other side
generate next grip.

Note though that would mean a xbar destination for
each possible grip value, not just a single
destination for the grip itself. Maybe three bits
of grip would be enough.

Alllll-though, if the signals are headed into
clearly distinguished XBars, couldn't we reuse
destination indices on a per XBar basis?

  Prolly if we wanted to,
  really really wanted to..

Hmm! We could also chain xbars together if we
wanted to, if we let the outbound signal continue
instead of being consumed when an inbound signal
turns off of it.

Reserve a destination meaning /dev/null and
consume everything that arrives there
[300:

Mon Jun 10 13:33:55 2024 OK how can we get a xbar
spike actually doing something?

 - Re-layout taps. Just do it. Do it now.[301:

Mon Jun 10 14:31:41 2024 OK, so, did that. Whole
thing fit in one tile, although not all in the
hidden sites.

Now what? In particular, how do the XBarSpace2D's
know what to take to fill their mTaps array? It
seems like they need extra configuration to know
what to do. Sometimes they'll copy mTaps from
their neighbors, other times they'll set mTaps
from nearby Terminaliases..
[302:

Mon Jun 10 14:44:16 2024 Maybe we could configure
incoming and outgoing aspects separately, based on
configuration in the delivered terms, and then the
rest of the xbar figures itself out based on
combining the incoming and outgoing configuration.

If the motor taps said 'incoming from the east'
and the sensor taps said 'outgoing to the south',
would it "just work"?
[303:

Tue Jun 11 11:08:09 2024 OK, so what are we
thinking here?

 - XBarSpace2D will propagate mTaps info
 - Terminalias will tell it which way(s) to
   propagate its idx? How really could that work?

In our new layout, outgoing sensor signals head
south, and incoming motor signals head west. So as
a osignal moves south, it passes various motor
rows and sees motor dests advertised from the
west, and (I guess) nothing advertised from the
east.

The osig reads the grip from the local XB, and
determines if it cares about the mdest it's
passing. If it does, it spawns an isig heading
toward the given mdest, possibly mapping its osig
value in the process.

Perhaps it could have a bitmap of desired mdests?
Something so we could consume it once it's turned
all desired corners?

That's unearned complexity at this point. Let's
see the crowds becoming a problem first.

So maybe if an osig arrives at an xb that has no
mTaps dests (except perhaps the osig's own,in the
opposite direction it's traveling), then the osig
just consumes itself there with no further fuss.

[304:

Tue Jun 11 11:42:39 2024 So, again. Restate
position.

We're saying maybe something like

  virtual DirMap Terminalias.propagateTap() ;

that xb calls to decide what to do? And the tap
returns a DirMap indicating 0 to 4 directions.

And xb does that anew each event? And if there's
more than one equally close tap it picks randomly?

And for 'uncommitted' dirs xb checks the
complementary ngb xb, and copies its vals if
they're committed?

Maaybe.

:304]

:303]
:302]

:301]

:300]

:299]

:298]

:297]

:296]

:295]

:294]

:293]

:292]
:291]
[305:

Fri Jun 14 09:05:16 2024 OK, trying to get XB tap
propagation going and it's hitting the guts of
Terminalias and LocalSpace2D. We need a branch or
a fork or something here.[306:

Fri Jun 14 09:08:50 2024 OK moved to new branch
'xbar10'. Continue there after grocery curbside go
and lunch..[307:

Fri Jun 14 15:57:45 2024 Plus a nap and a call..

OK, so let's just implement

  virtual AxialDirMap propagateTap() ;

in TermSensor and TermMotor, rather than trying to
graft it on from the side.[308:

Fri Jun 14 15:59:40 2024 Actually just implement
it in Terminalalias and let people override if
they want?
[309:

Sat Jun 15 09:23:57 2024 Gotten as far as needing
to know how we're really going to map between
terminalias elements and index numbers.

The only thing that makes sense is an array of
classids, right? Let's insert that in
TermTargetLibrary while leaving all the crazy
String stuff in there.

:309]
:308]


:307]

:306]

:305]
[310:

Sun Jun 16 00:10:52 2024 So okay had our Saturday
evening and now it's time to get the tap indices
propagating far beyond the taps and their
immediate neighborhood.

So that 'just' means: if we're not originating for
a particular direction, we should look in the
opposite direction and copy what they're
advertising.

Right?

We can even take it if it's uninitted, because we
want to be uninitted then too, yes?
[311:

Sun Jun 16 00:42:48 2024 OK it's time to play
'Dave's Traditional High-Order Bit Problem' once
again: Do the mTaps tell you which way tap idxs
propagate, or which way a signal should move to
reach the tap?

We started out thinking the latter, but we appear
to have implemented the former, at the moment.

I think we do want the latter. So that means if a
tap is saying 'outgoing to south', that means we
want to set the local XB's north to that tap idx?

And if a tap is saying 'incoming from east', we
set the local XB's west to that tap idx?[312:

Sun Jun 16 01:02:10 2024 OK so now the mTaps are
looking more like I was expecting.

:312]

:311]

:310]
[313:

Sun Jun 16 09:55:34 2024 OK, how do we start
routing signals on the XBar, now? I think make a
new Sig class? Have to review Signal and see how
bad it would be.[314:

Sun Jun 16 10:01:09 2024 Existing Signal has

  typedef Tissue.GradIdx GradIdx;
  typedef ClassUtils.ClassId ClassId;
  GradIdx mClimbGradIdx;
  ClassId mSourceSignal;
  ASCII mValue;

and we don't want the GradIdx now. And geez
ClassId is just Unsigned these days - that's 32
foggen bits:

  | COMPONENTS of Signal <78> (43 bits/28 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 3	| mClimbGradIdx	| Unsigned(3)
  | 3	| 32	| mSourceSignal	| Unsigned
  | 35	| 8	| mValue	| Unsigned(8)
  | 43	| 0	| ew	| EventWindow <44>
  | 43	| 0	| random	| Random <46>
  | 43	| 0	| super	| UrSelf <0>
  | 43	| 0	| base	| DTU <48>

[315:

Sun Jun 16 10:04:51 2024 And we want to make room
for both 'hardcoded' and 'programmable' routing,
so let's think about that for a second here.

We imagined that 'hardcoded' routing depended just
on the Signal internals plus the 'cross streets'
the (outgoing) signal passes as it moves down its
column.

And we imagined, I guess, that the (incoming)
signal just headed across its row until it arrived
at its destination (waiting until it then got
consumed, somehow, I guess).

How much space is there in XB? [316:

Sun Jun 16 10:21:30 2024

  | COMPONENTS of XBarSpace2D <130> (49 bits/22 unused):

and I think I must not think about pushing signals
inside of XB. Because, at the very least, we need
signals going in two directions to not interfere
with each other too greatly.

[317:

Sun Jun 16 10:40:36 2024 Buuut if we could route
one incoming and one outgoing sig through each XB,
then we could preserve all the HC3 free space for
programming override purposes.[318:

Sun Jun 16 10:43:34 2024 So at the moment XB is
inheriting from

  local typedef LocalSpace2DT(7u,1u,4u,7u,1u) QSpace2D;

which is burning 29 bits:

  | COMPONENTS of LocalSpace2DT(7u,1u,4u,7u,1u) <99> (29 bits/35 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 7	| mPosX	| Int(7)
  | 7	| 7	| mPosY	| Int(7)
  | 14	| 7	| mOurGradients[1]	| GradientStgT(7u) <86>
  | 21	| 1	| mTag	| Unsigned(1)
  | 22	| 4	| mLocalSpace2DGrip	| GripStgT(4u) <90>
  | 26	| 0	| super	| LocalSpace2D <81>

of which we could buy back seven once we can zero
out mOurGradients and not have mfms choke. Maybe
we should look at that right now and see if it
might not be too hard..[319:

Mon Jun 17 14:21:38 2024 Now I'm thinking again
about routing signals inside of the XBs. In
particular, when you boil the current Signal down
to its essence, it's mostly 'just' an 8 bit value
plus a source.

But with the XB.mTaps, we can get source
information from the column, and all we 'really'
need is the 8 bit value. Plus a little OoB
occupancy status perhaps - maybe 10 bits tops.

With one 10B slot for an 'outgoing' signal (from
the column mTap) and one 10B slot for an
'incoming' signal (to the row mTap)..
[320:

Mon Jun 17 15:02:17 2024 Well okay in for a penny,
made 9B SlotSig and put two in XBarSpace2D. Now
theoretically we could make XB code that forwarded
and routed the (outbound) SlotSigs. (Do we imagine
inbound SlotSigs might combine in the fabric?)

Idea would be to get classids for the column and
row taps, then instantiate the column tap (?) and
ask it what it wants to do?

Or maybe we'd rather build a transient Router, and
delegate the whole routing mess to it? Especially
because we're going to want more 'complex and
programmable' routing down the road.[321:

Mon Jun 17 16:56:04 2024 OK we started into Bool
Router.tryRoute(..) and got as far as wondering if
we need to distinguish 'cant route because blocked
on incoming line' vs 'cant route because nothing
to do here'. Since we don't have a caller yet
we're not sure what they need[323:

Mon Jun 17 23:19:23 2024 So what do we think?

:323][322:

Mon Jun 17 22:57:14 2024 (Made a fedi poll asking
if people tended to write functions without
callers or calls to non-existent functions.. it's
got 89 votes after six hours - pretty evenly
split!)

:322]

:321]

:320]

:319]

:318]

:317]

:316]

:315]

:314]

:313]
[324:

Tue Jun 18 15:14:09 2024 Well so theoretically we
have Router.trySwitch(..) implemented for the
simplest case, but untested. We still need to
modify Terminalias to

(1) Inject signals into XB slotsigs, rather than
    deploying Signals, and

(2) Provide a mapSig(SlotSig & in, TapIdx otix)
    implementation to specify what destinations
    this ssig wants, and to map the signal
    appropriately. ('Later' we'll want to defer
    that to programmability crap in the xb
    pockets..)

[325:

Tue Jun 18 16:18:53 2024 Well, I think I'm going
to start a whole new Terminalias.ulam rather than
rehack the gradient-base one.. So while I'm at it,
let's officially go to Tap.ulam instead of Terminalias

:325]
:324]
[326:

Thu Jun 20 21:38:22 2024 Soooo, previously TOCK
was sending signals to either MLRF or MRRF
depending on its 'internal clock'. How the heck
are we supposed to do that with SlotSigs??? We'd
have to have extra state to send along with the
signal, that would get accessed during the route
mapping from outgoing to incoming. Do we even have
room to do that?[327:

Thu Jun 20 21:45:08 2024 Also, how do we plan to
update the grip?

:327]

:326]
[328:

Sat Jun 22 11:33:15 2024 OK so the code is finally
building, once again, and running but not really
doing anything. I guess the first step should be
to get Beevee running here again, and get the
spine reconnected, and then debug our way to
seeing signals move.

After that we can deal with how to update the
grip. [329:

Sat Jun 22 12:10:34 2024 OK, so (with once again
way too much fuss) the spine to mfms is running
again.

And we're getting from TermSensor.behave()
successfully, but it's not delivering a SlotSig
into the XB. So let's focus on that for a couple
minutes here before meeting starts.[330:

Sat Jun 22 12:30:51 2024 OK, looks like we're now
injecting SlotSigs from TermSensors, but the
internal XBs aren't propagating them.[331:

Sat Jun 22 12:32:23 2024 I think that's because we
don't know how to do the router switching yet. May
not be able to push on that much before meeting.

Let's just take a look at the XB code..
[332:

Sat Jun 22 12:44:36 2024 OK, now we're getting
into Router.trySwitch(..) from XB..State.act(..),
and trySwitch is returning false.

XXX Pick up there next go.
[333:

Sat Jun 22 22:38:42 2024 OK have been working
through trySwitch and have arrived at an issue: If
we're an outbound signal heading down a column,
and we're at an XB with an occupied inbound, do
we:

 (1) Block until the inbound is free?
 (2) Consume the outbound signal?
 (3) Determine if the given iss even wants to
     switch to this row, and continue propagating
     down if it doesn't?

It seems clearly wrong to block on a row that the
signal doesn't want, but the current
Router.mapSig(..) is asked to decide if routing is
to happen, and if so to map the signal, at the
same time.

My initial instinct was to separate the boolean
routing decision from the signal mapping function,
so we could just check if this row is even
desirable, before checking (for example) if the
row is blocked.

Writing that out though, it seems like if mapSig
guarantees not to touch the outbound signal unless
it is going to return true, then we could
propagate downwards otherwise. And keep it a
single API call.

[334:

Sat Jun 22 23:05:45 2024 But still, if we're going
to want multidispatch - which we are - we're going
to need to map the 'same' outgoing signal multiple
times. So even if mapSig says yes, we should have
given it a copy of the iss anyway, so we can keep
progagating until we run out of rows..

[335:

Sun Jun 23 00:16:42 2024 OK it looks like we might
be propagating outbound plausibly. Need to
propagate inbound as well - do we do that here?
Let's say yes for now.[336:

Sun Jun 23 00:46:58 2024 OK it looks like we might
actually be routing signals all the way to their
incoming destination XB. But two questions:

 (1) are the TAPs picking up the signals, and
 (2) do we want to hold incoming sigs until they do?
[337:

Sun Jun 23 00:49:32 2024 Well, at the moment,
TermMotor is acting like it's an XB, not a TAP, so
it's looking in all the wrong places..

If the destination XBs could know they're the
destination, we could hold signals for them. And
I'd think they could know that since they scan for
the TAPs during observe(..), right?

:337]
:336]

:335]

:334]

:333]
:332]
:331]

:330]

:329]

:328]
[338:

Sun Jun 23 15:36:31 2024 Hmm just saw DeliverTerm
put two TAPs in the Moore ngb of a single XB.
Really don't want that these days..[339:

Sun Jun 23 16:36:41 2024 OK I think that won't
happen any more. We shall see.

:339]

:338]
[340:

Sun Jun 23 16:37:57 2024 OK, among the many things
we need to do urgently and immediately, I think we
need to decide how actually we're going to have
Router.mapSig(..) work.
[341:

Sun Jun 23 23:19:59 2024 Well, for starters we'll
pass xb and xbs to mapSig..? Unclear I guess. Push
on.

mapSig(SlotSig & slot, TapIdx out, TapIdx in)
  (1) Build a TermTargetLibrary
  (2) Get classids for out and in via
      ttl.getClassIdFromTapIdx(..)
  (3)

[342:

Mon Jun 24 00:20:03 2024 Doh just use a GripInfo
from the GripInfoMap, which is totally implemented
and I think still pretty much all usable.
[343:

Mon Jun 24 08:54:42 2024 Not quite there yet but
we're close to 'just' needing a way for GRIP to
actually change the grip.

[344:

Mon Jun 24 09:04:23 2024 Actually we need

(1) How to (tell everybody when we) change the grip
(2) How to handle the 'hidden units' GRIP and TOCK
[345:

Mon Jun 24 23:09:21 2024 OK so we think we're
going to hack the hidden units by using
old(-style) embodied signals to hillclimb toward
their destination, and hack the recipients to
check for them.

We think there's just two cases where it's needed,
to replicate the previous circuitry?
(1) From GRIP to the XB root for the gripnum
(2) [346:

Mon Jun 24 23:15:06 2024 Wait. Why do we need
input to TOCK? Couldn't it be just a sensor
(albeit with disgusting internal state)?

If we have GRIP do all the grip changing.. TOCK
just ships its count (like the high order 8 bits
of something bigger) and - if the grip says we
should - we map those signals onto MLRF and MRRF
during switching.

Let's review what TOCK and I think it's
  doing..[347:

Mon Jun 24 23:21:48 2024 It seems clear that
TOCK.ulam takes input only for the prevailing
grip.

Let's grep for users..[348:

Mon Jun 24 23:22:43 2024 I see nothing of note.

Let's fucking do this.

TOCK is transitioning from motor to sensor, away!
[349:

Mon Jun 24 23:53:07 2024 OK so now TOCK is sitting
in the rightmost column, broadcasting 'random'
signals down and switching them, so far, to no
one. [350:

Tue Jun 25 00:48:49 2024 Cleaned up TOCK a bit,
admitting its lameass fundamental nature by
inheriting from Once and randomizing its clock
state..

So. Now we need GRIP to send gripnums to the
  root.[351:

Tue Jun 25 07:56:58 2024 OK, urgh, another major
thinko reporting for duty here. We made the XBar -
and in particular, the SlotSig - with the idea
that once a signal was switched, the source of the
signal no longer mattered.

But we're sending all kinds of signals to GRIP,
and GRIP wants to know the sources of signals -
for example, whether the signals are yellow or red
or what.

Time to review the bit budget again.[352:

Tue Jun 25 08:01:23 2024 Well, it kind of looks
like this:

  | COMPONENTS of XBarSpace2D <119> (61 bits/10 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 20	| mTaps[4]	| Unsigned(5)
  | 20	| 18	| mSigs[2]	| SlotSig <118>

where we conclude that
(1) a single TapIdx is Unsigned(5), so
(2) we could extend a SlotSig by five bits,
    and JUST BARELY still fit into an XB, with a
    grand total of zero bits remaining, given two
    mSigs and the current ten bits unused.

[353:

Tue Jun 25 09:00:46 2024 OK so GRIP is updating
its state variables again, and deciding when it
wants to change the grip. Now we have to
communicate those grip changes to the root.

How does DeliverTerm work at the moment?[354:

Tue Jun 25 09:04:53 2024 Completely manually, it
appears. Oh well.

[355:

Fri Jun 28 10:32:55 2024 OK, so, Beevee's new xbar
brain has been kind of working for a couple days
now, and I've been debugging and tweaking and
trying to get it to work better.

:355]

:354]

:353]

:352]

:351]

:350]

:349]
:348]

:347]

:346]
:345]
:344]

:343]

:342]


:341]
:340]
[356:

Sat Jun 29 10:17:18 2024 So, could we get a tiny
bit further here? Could we, perhaps whack up a
second XB to go west of the motor column that
would somehow provide motor->motor feedback? I'm
thinking of having the eyestalk taps compute
average differences in colors (kind of like GRIP
except signed) and drive each eyestalk by the
yellow or red difference, depending on the grip.

We can do that much right now, but I was hoping to
then also drive the main motors by the eyestalk
angles, trying to get the eyestalks back to their
default positions by turning the body.

[357:

Sat Jun 29 10:25:12 2024 But if we really could
compute color differences and drive the eyestalk
motors right now, what's say let's get that going,
even though it might fuck up the various grip
dynamics.

TODO

 - Review eyestalk code
 - Review GRIP fixmax code
 - Review motor.py (etc) code
 - Add fixmax slots to eyestalks
 - Add eyestalk motors to L/R sensors
 - Observe eyestalk driving motor terms
 - Observe Beevee's eyestalks pivoting

:357]

:356]
[358:

Sat Jun 29 10:31:07 2024 So, looking at
TermEyeStalk in TAP.ulam.

 - MLEY currently has 41b free
 - TermEyeStalk currently has one 20b FixMax,
   supposedly representing the desired angle.
 - Incoming signal processing is currently
   commented-out of its behave().

We could add two more fixmax's and still have 1b
left.. Or we could just apply straight to the
desired angle, depending on the grip?

Let's just get the signals affecting the existing
fixmax, for starters.[359:

Sat Jun 29 10:44:56 2024 So our goal is
(1) Send
    SLLY.classidof,  //< 10 Left Left-side Yellow Detector
    SLRY.classidof,  //< 11 Left Right-side Yellow Detector
to
    MLEY.classidof,  //< 14 Left Eyestalk angle Motor

and
    SRLY.classidof,  //< 12 Right Left-side Yellow Detector
    SRRY.classidof,  //< 13 Right Right-side Yellow Detector
to
    MREY.classidof,  //< 15 Right Eyestalk angle Motor

and apply them somehow

[360:

Sat Jun 29 10:54:39 2024 OK we suspect we may now
be sending the signals as in (1) above.. still
need to soak them up at the taps. And remap them
through the switches.[361:

Sat Jun 29 12:01:49 2024 OK it looks like we're
eating up the signals at MLEY and MREY, although
only MREY seems to have non-zero mStalkAngle.
(Which is plausible looking at the sim.)

But we have no remapping going on so how do with
do a differencing operation here?[362:

Sat Jun 29 13:19:52 2024 OK, we may have
TermEyeStalk holding a fixed point Int rather than
Unsigned, but we can't tell until we remap the
half-signals.. [363:

Sat Jun 29 13:57:17 2024 May have done that but no
sign of the signals getting through to the
'actual' eyestalks. Let's switch to .py.

:363]

:362]

:361]

:360]


:359]

:358]
[364:

Thu Jul  4 11:29:32 2024 OK, so once again got
through t2sday and recovered some. Need to make
xbar plans to not waste too much time. Much to do.
Much

TODO
 - Review and rethink how stateful taps like GRIP
   decide when to update their state. What's their
   timebase?
   = Currently, I believe they update only when
     they consume an inbound signal. Which makes
     some sense, but we have choices about when to
     send signals to any given dest, and on this
     view those decisions will affect their time
     constants.
   = Or could we have a way to detect spinal input
     in GRIP even though it's not reified outside
     Beevee's brain. (Do we maybe already have
     that?)
   = There's an additional question there, though:
     if we don't update on every arrived signal,
     what happens to the rest of the signals? It's
     like we want to accumulate signals somehow,
     and then commit them once per period.
   = I was playing fast and loose with the "don't
     send 0 signals while hunting" stuff, and I
     suspect that should go, on the grounds that
     all signals, whatever their values, form part
     of the implied timebase?
[365:

Fri Jul  5 01:29:06 2024

more TODO

 - Review current XBar state deployment

 - Consider how to do more general crossbar stuff
   like parallel IO lines with I->O connections on
   the orthogonals

 - Consider how to make outgoing and incoming
   programmable on each line

[366:

Fri Jul  5 02:04:29 2024 A key power of a grip is
that it's non-local information. It's broadly
distributed and therefore can do largely
non-spatial computations as long as each component
action can be sited locally and parameterized
locally somewhere in the reach of the grip.

:366]

:365]


:364]
[367:

Fri Jul  5 15:28:40 2024 So what might a
generalized XBar look like? What's our current
budget? Yikes 2b unused:

  | COMPONENTS of XBarSpace2D <78> (69 bits/2 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 20	| mTaps[4]	| Unsigned(5)
  | 20	| 26	| mSigs[2]	| SlotSig <79>
  | 46	| 20	| super	| LocalSpace2DT(7u,1u,4u,1u,1u) <102>
  | 66	| 3	| base	| QDebugUtils <29>

[368:

Fri Jul  5 15:30:06 2024 Maybe we should take the
time now to get mfms fixed to be able to handle 0
length arrays?[369:

Fri Jul  5 15:33:27 2024 Well even if I did that
it would only buy 2b in XBSpace2D so maybe screw
that? 13b per SlotSig is pretty lot isn't it?[370:

Fri Jul  5 15:49:49 2024 Well, it's 8b for a
signal and 5b for a source. Unless I'm ready to go
down to max 16 rather than max 32 taps seems like
not a lot to do. Or 7b or 6b signal values I
suppose. [371:

Fri Jul  5 15:55:53 2024 What do I want extra bits
for? To specify uses on a per row&column basis?
Well at a minimum that could be just 1b each -- in
or out -- so only 2b total..

But couldn't we infer that, perhaps, from the
mTaps[4]? Why do we need any bits at all for
that? Basically we're just assuming things are set
up as outgoing columns and incoming rows, at the
moment. [372:

Fri Jul  5 16:01:52 2024 How could it work? We'd
still need to associate the mSig[0] with column?
Or with outbound?

I guess one issue is if we're trying to do the
parallel I/Os (on the rows, say) then how do we
know which column represents the bridge from O to
I? Repeat the dest on the switching column?
Possibly.. But then could only switch one pair per
column.. which is how such an xbar works, I think,
but we could in principle do better.

         a  b  c
            ---1
         ---|--2
         |  ---3
         |     4
         |  ---5
         ---|--6
            ---7

 1 <-> 3 col b
 5 <-> 7 col b also
 2 <-> 6 col a

:372]

:371]

:370]

:369]

:368]

:367]
[373:

Sat Jul  6 08:18:22 2024 So what about expecting
xb atoms to get down to looking in their pockets
for additional routing info? We said we were going
to do that, maybe it's time to get started.

Our goal this month is sequence, so we could be
thinking about associations between past and
future states. One obvious idea would be to try to
associate between grip changes, or from entering a
grip to leaving it, which seems slightly
different.

We'd like to have some hidden units travelling
along there through the memory, so we could start
to form postulated state about the world and
distinguish similar states based only on the
difference in our hidden units when the states
arrives.

we should be able to drive an figure-8 shape based
on two "Os" - like:

   ^>>x<<<
   ^  v  ^
   ^  v  ^
   ^<<Y>>^

where the two passages down the center column are
"identical" but if we turned right at X we turn
left at Y and if we turned left at X we turn right
at Y.

And then we claim that memory of our action at X,
and its subsequent reuse at Y, is a beginning of a
'spatial map' or something.

[374:

Sat Jul  6 09:27:32 2024 If we had a 3x3 coloring
on the checkerboard we 'could' tell roughly what
direction we're going independent of ew geometry,
right?

      wh bk bl

      bk bl wh

      bl wh bk


  wh bk bl wh bk bl wh bk bl

  bk bl wh bk bl wh bk bl wh

  bl wh bk bl wh bk bl wh bk

  wh bk bl wh bk bl wh bk bl

  bk bl wh bk bl wh bk bl wh

  bl wh bk bl wh bk bl wh bk

or maybe stagger it?

  wh  bk  bl  wh  bk  bl  wh  bk  bl

    wh  bk  bl  wh  bk  bl  wh  bk  bl

  bl  wh  bk  bl  wh  bk  bl  wh  bk
                    \ /
    bl  wh  bk  bl--wh--bk  bl  wh  bk
                    / \
  bk  bl  wh  bk  bl  wh  bk  bl  wh

    bk  bl  wh  bk  bl  wh  bk  bl  wh

  wh  bk  bl  wh  bk  bl  wh  bk  bl

[375:

Sat Jul  6 10:20:14 2024 Well not super clear what
that accomplishes. Be more helpful I'd think to
have multiscale signaling - big squares and
littler ones - but is that tantamount to
precooking the spatial mapping? Maybe kinda.

What if we just give Beevee some kind of 'corner
grey detectors' that can distinguish the existing
checkeboard squares, and go with that? And it's on
beevee to count transitions or whatever. If
Beevee's got grey detectors on all four corners,
it could distinguish direction of edge crossings
and such, at least in principle.

[376:

Sat Jul  6 10:29:13 2024 Tempting. It's got good
own-your-own-choices nature.

[377:

Sat Jul  6 10:32:42 2024 Existing checkerboard
colors are

dark:  #313131
light: #5c5c5c

[378:

Sat Jul  6 10:35:08 2024 And the current
checkerboard size makes each square just a bit
larger than Beevee is long. Beevee's crossing
edges of squares plenty often.

[379:

Sat Jul  6 10:42:13 2024 Fog it lets make grey
corner cameras. Got to get going here.
[380:

Sat Jul  6 10:43:59 2024 Guess the first step is
make new links for the new cameras to hang off of.
[381:

Sun Jul  7 17:15:50 2024 OK, so some progress:

 - the corner cameras are working plausibly
 - There's a rendering of them now in the montage
 - Their values are getting fed to the brain

so that's something. But:

 - the brain has no taps for them
 - the layout doesn't mention them
 - we have no real idea how to use them

[382:

Sun Jul  7 17:19:49 2024 So I kind of think we're
back to XB generalization stuff. Can we have a
little review of that?[383:

Sun Jul  7 17:21:34 2024 we do note that the
potential for a 'going straight' grip based on the
corner greys could help a lot with the fantasized
'figure-8' route of :373: above.[384:

Sun Jul  7 17:26:19 2024 Seems like one key bit
is:

    But couldn't we infer [xb directions], from the
    mTaps[4]? Why do we need any bits at all for
    that? Basically we're just assuming things are set
    up as outgoing columns and incoming rows, at the
    moment.

from :368: above.

And then this:

    I guess one issue is if we're trying to do the
    parallel I/Os (on the rows, say) then how do we
    know which column represents the bridge from O to
    I?

from :372:. But sitting here now, I'd think we'd
do that with a pocket atom saying when to turn and
which way to go.

But when the signal turns, is it then 'inbound',
or still 'outbound'? The whole inbound/outbound
distinction seems problematic with I's and O's
both on (say) rows.

Maybe we do want those last two bits, to say which
way is 'forward' for row and column? Or the grip
could tell us? How?

Getting towards next stage cooking time out in the
world here..

[385:

Sun Jul  7 17:35:19 2024 Imagining that we have
'scratch' columns to bridge I and O rows isn't
really in the "use the space for multiscale
storage" where we could change the use of a column
without reset -- for example, to turn it around,
and benefit from reinterpreting existing
configuration.

:385]

:384]

:383]

:382]

:381]
:380]

:379]

:378]

:377]:376]
:375]
:374]
:373]
[386:

Mon Jul  8 11:51:45 2024 OK we have to get to
implementable somehow here. Time for:

  Minimal, minimal.

So I'm wondering: What about just little 'traffic
sign' nodes that can (even) be used with no larger
crossbar. Just like: I can hold a couple signals
and I have instructions that say things like
'right turn for slot A' and 'straight on for slot
B' or whatever.

So the main point would be getting rid of the
mTaps[4], I guess, which would save a lot of room
for these traffic indicators.

And the point is we could use them to construct
point-to-point 'signal wires' for adhoc routing or
whatever.[387:

Mon Jul  8 11:59:30 2024 And we could use them to
route from like MLEY/MREY to say GRIP, without a
whole separate crossbar?

I wonder how many sigs we could route if we took
out the taps?
[388:

Mon Jul  8 12:04:31 2024 Hmm, sigs are 13b and
taps are only 5b. so ditching four taps only buys
us one more sig (plus 7b free for routing/misc).

That's because sigs have an 8b value (plus a 5b
source). That damn 8b value again. It's so big.

Do we really need a source? Do we really need
allll of a source? Do we really need all 8b of a
signal?

[389:

Mon Jul  8 12:27:44 2024 Well, say we do. For
now. Even with just three sigs we can have the
fabled two wires crossing with room to spare.

[390:

Mon Jul  8 12:36:25 2024 Come on what's a first
use case here?

Well, I'd like to start doing something with the
ground sensors. (Shall we settle on calling them
'ground sensors'? 'Floor' sounds so wussy and
civilized even though Beevee has never existed on
anything else.)
[391:

Mon Jul  8 15:24:53 2024 So I'd like to have a
GoStraight grip, that would drive the motors based
on the ground sensors and track the passing
checkerboards. Perhaps straddling an edge between
the floor tiles.
[392:

Mon Jul  8 15:26:57 2024 So how would we do that?
Do we need 'subgrips' to find an edge vs follow
it? Let's just focus on follow for now.

So we should have state causing us to expect
upcoming ground transitions, and we should compute
an error signal between expectations and
observations. And then one grip is to travel
straight at a certain speed. I guess the
GoStraight grip could have a speed port ((that
could be gripped as input and/or output??))

And our sense of speed is based on our sense of
time which is based on counting spinal signals?

:392]
Then I'd like a Turn grip, that would turn right
or left based on conditions.

:391]
:390]
:389]

:388]
:387]

(Already running all ahead to imagine pocketworms
that navigate somewhere and set these switches for
signals to follow. But minimal, minimal.)

:386]
[393:

Mon Jul  8 15:33:52 2024 What about a linear
arithmetic worm? Like a signal path where is the
steps also condition the signal somehow. Where we
had a language to describe such paths.

Is that important, internally, vs just having an
instance of the worm to copy?

but where of course did the first instance come
from? Ulam constants? Or some kind of language,
and then we're right back in it, hmm?

[394:

Mon Jul  8 15:39:31 2024 Count distance in
unary. Advance a sequencing thing - single step a
sequential program, on each recognized tile
crossing.

[395:

Mon Jul  8 15:55:53 2024 Grip-specific
taps. Reconfigure xb by changing selected taps
when grip changes.

:395]

:394]

:393]
[396:

Mon Jul  8 16:44:03 2024 minimal minimal.

TODO

[398: Tue Jul  9 14:54:32 2024 builds but it's stubs..
DONE  :398] - Make a new grip called TRAVEL
[500: does it in all grips atm, but let's say
DONE  :500] - Make a new xb in another tile, that takes the
   ground sensors and routes to the motors
   (somehow) during TRAVEL grip
 - Change GRIP to go to TRAVEL instead of EXPLORE,
   for testing
 - Somehow see TRAVEL finding and following the
   tiles edges, turning randomly. (So TRAVEL is
   like EXPLORE except it follows edges.)
 - See TRAVEL running.
 - Say cool
 - Make more to-do

:396]
[397:

Tue Jul  9 14:41:32 2024 OK come on we committed a
start of a rev to the esaay so let's knock off a
couple items here too.

:397]
[399:

Tue Jul  9 14:55:00 2024 OK, let's have GRIP try
to start/maintain another xb to its west..? Or
maybe just seed it by hand for starters?[400:

Wed Jul 10 02:26:40 2024 Well I took a few hours
to finally deal with the MFM core being unable to
deal with zero-length arrays, even though ulam is
perfectly capable of dealing with them.

:400]

:399]
[401:

Fri Jul 12 09:35:25 2024 So okay. Made S[FR][LR]G
taps and laid them out. Issue now is the tap
propagation through the xbspace2ds: the current
code propagates tap info S for sensors and E for
motors, and that propagation currently continues
until the frickin edge of creation.

It seems 'obvious' we need some kind of
tap-propagation-stopper, so we can have more or
less fully separated xbs.

I'd think down the road a 'prop-stopper' might
also be an inter-xb-bridge of some kind, but step
by step.

So, can we define a syntax for representing
propstops? stoprots?

Could there be a default 'flood around an xb' kind
of thing, so that whenever a sensor (motor) has no
sensor to its east (south), then a propstop is
placed there automatically. And propstops
reproduce south (east) automatically as long as
there's defined north and west taps to support
them.

And 'real taps', or 'real tap propagations' or
something, are happy to overwrite propstops as
needed.

[402:

Fri Jul 12 09:59:24 2024 So it that about
implementable? [403:

Fri Jul 12 10:10:22 2024 Started making

   element HALT : TermHidden { ..

but now wondering if we want propstop to be just a
property on xb rather than a 'pseudoTAP'.

Remembering that bits are very tight in xb
though.[404:

Fri Jul 12 10:15:30 2024 Could we reserve
(cTAPIDX_NONE - 1u) and call it cTAPIDX_HALT ?

and the idea would be what? that an xb with only
zero or one real mTap idx sets itself to HALT? So
basically everything would set itself to HALT at
first? And actual routing would have to spread
from inside the NW corner, where that xb would be
the only one seeing two taps, so it would
propagate, and then its ngbs could propagate, and
so forth.

And we can do that right now, right? Just rewrite
the propagation rules and treat cTAPIDX_NONE as
meaning HALT (too)?

Let's see if we can do it.

Maybe after blunch though.

:404]

:403]

:402]

:401]
[405:

Sun Jul 14 11:04:31 2024 OK so lost time on this
and that and the other thing too but I really
really want to see the new xb setup working
today. Right now I'm kind of confused how
XBstate.stabilize currently works and how we want
it to work.

Let's do fresh start here and then see how it
corresponds with what we have.

goals: set up current mTaps based on local TAP if
any plus xb ngbs.
[406:

Sun Jul 14 11:13:38 2024 do we maybe not care what
the TAP says about propdirs? Since we have this
new double-axis concept? But then what does xb do
with a tap? send it in all four directions? that
would change the existing behavior, which allows
for signals to run down xbs that have taps, as
long as those taps don't propagate in directions
the signal wants to run.[407:

Sun Jul 14 11:21:14 2024 So I guess that means
we'll keep the ask-the-TAP-for-propdirs stage for
now? But, we could have signals say north and
south, and have motors say east and west, and rely
on the double-axis rule to limit the propagation
appropriately.[408:

Sun Jul 14 11:32:02 2024 So okay: keep going in
stabilize..

:408]

:407]

  :406]
XBarSpace2DState.stabilize:
 - Call super and bail if needed[409:
 - set our mTaps all none
 - get propdirs if has tap
 - set mTaps[propdirs] to tapidx
 - visit ngbs and count up
   = if our mTap[ngbdir] is set
   = if ngb has prop to us
 - if count < 2 bail
 - visit ngbs again doh
   = if ngb has prop to us and
     our mTap is unset, set it
 - done?
[410:

Sun Jul 14 12:41:10 2024 Well maybe it's "count up
1 if any propdirs set AKA have a tap" rather. So
we could do:

 - Call super and bail if needed[409:
 - set our mTaps all none
 - visit ngbs and count up for each ngb that has prop to us
 - get propdirs if any (creating tap and bailing if needed)
 - count one if propdirs nonzero
 - set mTaps[propdirs] = tapidx [ORIGINATE]
 - if count < 2 bail
 - visit ngbs again doh [PROPAGATE]
   = if ngb has prop to us and our mTap is unset, set it
 - done.
[411:

Mon Jul 15 02:32:04 2024 Well it took forever, but
that last breakdown, in :410:, seemed to do the
trick. It looks like we have self-limiting xb
field initialization. Even looks like we have
self-erasing field if the border conditions
change.
[412:

Mon Jul 15 06:02:16 2024 So, pop pop pop. Can we
make a plan for trying to use the grey sensors
now? First goal would be to drive square to an
edge when using the TRAVL grip.

We'd like to convert a L-R pair to a difference
signal so that if L changes first we drive the R
wheel more, and if R changes first we drive the L
wheel more.

TRAVL
 - default: go fwd at say 10,10
 - compare L and R to their backavg values
 - derive +ive and -ive pulses on each
 - derive absolute value pulses on each?
 - compute difference of abs pulses (|pL|-|pR|)
   = if diff > 0 drive R more L less
   = if diff < 0 drive L more R less

See what something like that does?

Can we even implement that?

:412]
:411]
:410]
:409]

:405]
[413:

Mon Jul 15 12:04:27 2024 Could we just say the
idea is to bring signals closer together, and once
they're adjacent (in HC3 space) we do the
(2-input) computation and move on?

So, for a degenerate example, if we put SFRG and
SFLG next to each other (as they are right now) we
can compute like L-R in one and R-L in the other
(or L+R and L-R in the traditional way, or
whatever we want) and ship them into the xb in
that form. Now, the front and read L-R signals
would most naturally be distance 2 HC3, so they
couldn't interact directly, but we could turn the
corners in the switch to bring them adjacent, for
further operations.[414:

Mon Jul 15 12:12:21 2024 Now, actually, I'm not
sure we need to bring F and R signals together?
since they're not synchronized except by the
'happenstance' relationship between the
checkerboard size and Beevee's length.

"But it was meant to be an example."
[415:

Mon Jul 15 12:23:52 2024 Do we have room in SFRG
(etc) to store a backavg?[416:

Mon Jul 15 12:24:43 2024 Hmm SFRG has 61b
free. Guess we do.

Now if we wanted to be "more general", we could
implement an outboard backavger, and deploy them
next to the taps. And that might be worth trying,
because we suspect we'd like to backavg lots of
values.. We make a backavg API and etc..

[417:

Mon Jul 15 12:27:32 2024 Althooooooough, we do
have 61b in every foggen TAP at the moment. Maybe
just put it in every damn one of them?[418:

Tue Jul 16 07:35:38 2024 Haven't done that yet but
still thinking of doing so. Problem with backavg
overall is it depends on the rate of updating, and
we don't have a clear sense of that at the
moment. If we could delay signals long enough to
meet up with other signals, and compute full
snapshot values immediately, that would be more
self-clocking.. I guess up to the time we're
willing to block one signal before discarding it,
which would define/imply a time constant or
characteristic rate of the system or something.

[419:

Tue Jul 16 07:38:08 2024 We could have a terminal
node of some kind that could hold multiple
signals, and know whether it has them or not. So
we could route both operands to the same
destination, but with different sources, and the
terminal would hold any earlier-arriving signal
until the other operand signal arrives.

That seems pretty obvious, doesn't it? And with
61b available in a tap we could certainly spring
26b for two (or even 39b for three) signal
buffers..

:419]

:418]

:417]

:416]

:415]

:414]

:413]
[420:

Mon Jul 22 12:50:28 2024 OK, so today dammit we're
going to implement diffs of grey sensors using
TermHOp's -- Hidden Operations.

We're going to start that right now.[421:

Mon Jul 22 14:44:23 2024 OK we've made some
progress, and have TermDiff subclasses wanted to
subtract grey signals from each other. But we
placed the ops to the east rather than west of the
sensors, and so far signals aren't propagating.

And we presume that's due to Router.tryPropagation
doing stuff like:

        // Can we propagate the sig?
        AxialDir ad = (i == 0u) ? cS : cW; // HARDCODED PROPDIRS BOGUE-A-LOGUS

        {
          AxialDir xd = (i == 0u) ? cW : cN; // HARDCODED PROPDIRS BOGUE-A-LOGUS

so how can we change that?[422:

Mon Jul 22 14:59:10 2024 We want to say we can
propagate either way as long as there's only one
choice given the slot? Or we foggen diffuse if
there's two choices?
[423:

Wed Jul 24 01:50:56 2024 OK we still haven't got
this working yet.
[424:

Wed Jul 24 10:20:01 2024 How about: mSigs[0] go
away from defined tapidx; mSigs[1] go inbound
toward defined tapidx.

[425:

Wed Jul 24 14:57:44 2024 And how do we implement
that, exactly? In XBarSpace2DState.stabilize(..)
presumably?

And: In that rule, are we still considering only
N/S for outbound and E/W for inbound?

The main reason we want a consistent travel vector
is so we can be confident a signal will 'see' all
the cross traffic destinations without needing to
know where exactly they are ahead of time. And
that already needs not just N/S but a specific
choice between those.

We could have just two symmetries of XB:
 type 0: sense horiz, motor vert
 type 1: sense vert, motor horiz

and they would grow from a corner where they could
decide the correct sense based on analysis of the
(two) visible mTaps. That would give us I/O
routing either direction around all four corners,
which seems like pretty good generality for a
'crossbar' at this point..
[426:

Thu Jul 25 02:19:39 2024 OK so we're trying to do
this 'only two symmetry' idea, and we've gotten to
rewriting stabilize and wondering what the steps
really should be there.

In particular, we now have a

  Bool(3) mOutboundVertical;       // true means swap symmetry

data member standing for the 'two symmetries of
XB', but we're wondering how to stabilize that
value. In particular, just having a TAP, by
itself, doesn't determine that value. Only the
first INTERNAL xb can infer the symmetry.[427:

Thu Jul 25 12:15:20 2024 Instead of Bool(3) we
could go with Unary(2) I suppose, and have
cOUTHORZ = 0u, cOUTUNKN = 1u, cOUTVERT = 2u
or whatever..

And maybe say that cOUTUNKN is okay iff you have a
TAP, but not otherwise..

Could work.. A fair pain, but, what isn't?
[428:

Thu Jul 25 16:30:57 2024 OK so let's take another
run at a stabilize flow.

Questions to be resolved in stabilize
 - Am I entitled to persist? Bool persist = false;
 - Do I have a TAP? (handled by base class - mMinTap)
   = yes: persist = true;
   = no: should I have a TAP?
     = yes: make it & persist = true (or done)
 - What defined tapidx's do my ngbs have pointing at me?
   = if none I become or remain symmetry UNKN
   = if

[429:

Sat Jul 27 02:16:51 2024 OK fuck it what about
just specifying the symmetry in the TAP deployment
info. This is taking way way way way way too long
to be worth it. What's the current budget in
TAPs?[430:

Sat Jul 27 02:18:50 2024 Even in HOpBinary we have
28b avail. Let's take a Bool(3) for symmetry and
see how it goes..[431:

Sat Jul 27 02:44:37 2024 OK we've renamed to

  //// XBar Source Symmetry
  typedef Unary(2) XBSSy;
  constant XBSSy cXSH = 0u;     //< Xbar Sensors Horizontal
  constant XBSSy cXSU = 1u;     //< Xbar Sensor orientation Unknown
  constant XBSSy cXSV = 2u;     //< Xbar Sensors Vertical

and just defined a constant array in TermTarget to
specify (that everybody is cXSH, pretty much, at
the moment).

Now the idea is for anchor XBs to pick up the
symmetry from their taps, and for everybody else
just to get it from upstream. Fog it.[432:

Sat Jul 27 14:45:08 2024 OK, well we have a first
run of mSymmetry initting based on the explicit
TAP data member Bool(3) mSenseVert. But we're
making two xbs both with the same orientation.
Let's redraw our grey guy for vertical sensors and
see how far we get..
[433:

Sat Jul 27 15:16:33 2024 OK, it looks like we have
a functioning vertical sensor demo on the greys.
Yay for that.

Now we need to redo mTap propagation in
stabilize..
[434:

Sat Jul 27 23:58:06 2024 OK so fixed a bunch of
bugs and cleaned up some naming, and it looks like
we're at the point we need to redo TAPs handling
signals. Right now it seems like SlotSigs are
getting stuck and piling up backwards from the
'motor' end of things.[435:

Sun Jul 28 00:10:44 2024 OK current issue is
Router.trySwitch(..) is still using explicit
directions (like cN) for tap directions, and those
all need instead to

(1) take the symmetry into consideration, and
(2) be willing to route either way on the rail,
    depending on available dests.
[436:

Sun Jul 28 00:45:47 2024 Now maybe the issue is
the 'SenseDests' stuff? In particular, we don't
have any SenseDests declarations for the grey
sensors, I think, so it seems like they're failing
to route because of that?

But if we want grey sensor routing to happen in
all grips how do we do that without being too too
disgusting? Base class ditch?
[437:

Sun Jul 28 02:28:30 2024 OK now the question is,
when in Router.tryPropagation(..) how do we know
which way to go? Right now it's hardcoded and
that's fucking us up.[438:

Sun Jul 28 11:23:44 2024 So, pushing on
tryPropagation, trying to get clear with it. What
are the rules we're going for?

Reminder: At this point we are post trySwitch. So
outbound stuff stays outbound (or gets consumed).

 - Outbound: The forward direction is away from
   'the' occupied source mTap. (We are undefined
   if both outbound ends are set. Intention is to
   head away from the first initted that we see,
   checking the 'conventional' outbound dir
   first.)
 - But: Outbound cannot propagate in the forward
   direction unless there is some occupied dest
   mTap. 'activity on a cross street'. If no cross
   activity, outbound signal is consumed.
 - If outbound forward is occupied, block.

 - Inbound: The forward direction is toward 'the'
   occupied sink mTap. (Similar as above if both
   inbound ends are set - consider conventional
   sink dir first and go if possible.)
 - If inbound forward is occupied, block.
[440:

Sun Jul 28 13:11:06 2024 OK we have a
semiplausible tryInboundPropagation(..), untested.
Outbound should be similar except for the
cross-street business?

:440]
[439:

Sun Jul 28 11:51:27 2024 Well, so that might have
been a little helpful. In particular it seems to
suggest doing inbound and outbound separately
rather than trying to unify into a loop.

Let's try to set that up.

:439]

:438]

:437]

:436]
:435]

:434]

:433]
:432]

:431]

:430]

:429]

:428]

:427]

:426]

:425]

:424]
:423]
:422]


:421]

:420]
[441:

Mon Jul 29 00:21:49 2024 OK so some progress. Now
we may be up to needing to call
TermHOp.accept(SlotSig&) from somewhere, to start
getting signal operands stored.

:441]
[442:

Mon Jul 29 02:38:29 2024 Umm did we make a foggup
here? Are we consuming outbound signals when they
switch to inbound? Aren't we supposed to send them
on down the outbound rail, so they can see if
there's anybody else they want to ship to? Are we
even doing that anymore with this latest
redo?[443:

Mon Jul 29 02:46:59 2024 OK, we're still trying to
do that, so that's okay, but the current problem
appears to be that

(1)     AxialDir ad = xb.getPropagationDir(true,false); // try 'fwd' dir first
    sets ad == 1u, meaning cN, which we think is
    wrong (that's the 'reverse' dir), but also

(2) We are currently setting both mTaps[cN] and
    mTaps[cS] to the sensor tapid, so whichever
    one we consider first, I think we'll try to
    take..

[444:

Mon Jul 29 03:46:27 2024 OK, now we're not
propagating outbound away from the hasTAP XB
because we're looking for 'open space' in the
outbound direction (in this case cS) but we're
seeing mTaps[cS] set to the hasTAP id.

Do we really need a special case to start the
propagation? Urgh. Taking a break.

[445:

Mon Jul 29 06:02:49 2024 So, do we extend the XB
symmetry to four cases rather than two?

 SHC sensors horizontal and clockwise
 SHA sensors horizontal and anticlockwise
 SVC sensors vertical and clockwise
 SVA sensors vertical and anticlockwise

[446:

Mon Jul 29 06:05:44 2024 Can't we go away from a
matching tap for outbound? Isn't that enough? Only
packets from the sensor that owns the rail can
propagate outbound on it.
[447:

Mon Jul 29 13:24:41 2024 Seems like that mostly is
enough. But we're currently having an issue where
signals at the end of an outbound rail don't get
consumed, so they block outbound sigs all the way
back to the source.
[448:

Mon Jul 29 14:08:01 2024 Design problem seems to
be that trySwapAD conflates 'destination is
occupied' with 'destination has no symmetry' (and
other cases), when we want to block on occupied
but discard on no symmetry.[449:

Mon Jul 29 14:27:10 2024 OK we added a parameter
'Bool orDiscard' to trySwapAD and now things are
looking more plausible. In particular, the rails
are now mostly empty rather than all full. But I
think we've got a bug in that we shouldn't discard
at the end of an incoming rail that's got a tap on
it, because we want to let the tap consume the sig
when it gets a chance.[450:

Mon Jul 29 14:39:37 2024 Except we are already
saying 'false' for 'orDiscard' in that case..
[451:

Mon Jul 29 14:40:07 2024 So, acccctually, I think
we're up to needing our HOps to process inbound
signals? Pop pop pop? What's the state of that
code? [452:

Mon Jul 29 14:41:15 2024 State is we have
TermHOp.accept(SlotSig&) but nobody is currently
calling it.[453:

Mon Jul 29 15:20:12 2024 OK, so we now have
signals in the HOp arg slots. Finally! Now we have
to figure out

(1) When to execute the HOp, and
(2) What to do with the result..

[454:

Mon Jul 29 16:05:40 2024 We also want to start
thinking what's next as far as the TRAVL grip - in
particular, what do we do with the diff
outputs?[455:

Tue Jul 30 00:13:34 2024 So okay, so I'm thinking
we need to rough up a 'free floating signal
carrier' to traverse inter-crossbar gaps.

[456:

Tue Jul 30 00:35:09 2024 Could we make it
swapworm-based? Really like to have options for
more complex signaling, down the road.

What's the status of our SwapWorm stuff,
  here?[457:

Tue Jul 30 01:00:50 2024 Well, we've got
FreeWormBase.ulam and PDAnchor.ulam, and
WormBuilder appears to seed a PDAnchor that
hillclimbs toward the HC3 root, and that PDAnchor
is willing to string a bit of worm behind itself
in the SwapWorm fashion.[458:

Tue Jul 30 01:22:20 2024 PDAnchor was written for
LocalSpace rather than LocalSpace2D, but it was
pretty easy to fix up.

So I think PDAnchor could be a good basis for a
non-xb SlotSig carrier. We could just shoot one
out a ways, continuing in the 'inbound' direction
(which outside the xb becomes 'outbound') and have
it sit there, forward sigs down its length.

Could even have it be bidirectional if we had an
appropriate slotsig.

Hmm could we hap two mTaps in our 'axon', rather
than four, representing the tapidx at the head and
tail of the axon? Then just route potentially both
directions always on the 'inbound' rules?

Well if we had only one SlotSig in the worm we'd
need to deal with bidirectional swapping.. which
we've done before but it's a bit of a pain and it
does reflect reduced total channel capacity.

Let's spec out a two mTaps and two SlotSig 'Axon'
and see how it looks.[459:

Tue Jul 30 07:22:43 2024 Well we made quark Axon
and elements AxonHead and AxonTail, and they're
both at 26b unused. And they're untested. And we
still need an AxonMid as well.[460:

Tue Jul 30 09:45:52 2024 So, I'm making a bunch of
Axon-based stuff and I'm wondering whether we need
to store mTaps[2] in them. Vs say just putting one
mTap in each end, specifying the tapidx 'anchor'
for that end. But then why would believe the other
end is going where we wanted? We're supposed to
believe it because of its position in space..
bbuuut

[461:

Tue Jul 30 10:48:36 2024 Maybe just let it ride.
Belt and suspenders all the way.

:461]

:460]

:459]

:458]

:457]

:456]

:455]

:454]

:453]

:452]

:451]

:450]

:449]

:448]
:447]
:446]

:445]

:444]

:443]

:442]
[462:

Tue Jul 30 15:13:53 2024 OK. Thinking we should
only propagate an mAxonTaps if the end propagating
it can see the named tap, otherwise it should
propagate cTAPIDX_NONE. But! It can't erase its
corresponding mAxonTap, because it still needs to
know what it's looking for.

So we're (for now) saying that an AxonEnd has an
mTapFound that determines whether it has seen the
desired tap lately. And if so, then

  TapIdx AxonEnd.getAxonTap(AxonIdx idx)

will return cTAPIDX_NONE for its own end, unless
mTapFound is true, in which case it will return
its stored mAxonTaps[..].

[463:

Wed Jul 31 01:22:05 2024 Now, can we make a little
plan to actually test some of this stuff somehow?
[464:

Wed Jul 31 04:11:11 2024

 TODO

[471: Thu Aug  1 12:07:21 2024 (but way earlier)
DONE :471] - hand deploy an axon builder near hidden unit
[465: Thu Aug  1 01:54:16 2024
DONE :465]   = decays into Ah and At
[466: Thu Aug  1 12:00:55 2024 Well, searches randomly..
DONE :466]   = At searches for closest motor then stops
[467:
DONE :467]   = Ah searches for closest sensor then stops
[468:
DONE :468]   = See that work
[470: Thu Aug  1 12:07:07 2024
DONE :470]   = Make more to-do

:464]


:463]

:462]
[469:

Thu Aug  1 12:01:38 2024 So, more

TODO
[473: Thu Aug  1 13:23:13 2024
DONE :473] - virtualize temp-mid creation in FreeWormBase
[474:
DONE :474] - Get FWB to use AxonMid instead of FWTD
[475:
DONE :475] - See that run
[476: DONE, I think, but untested
:476] - Make it so AxonMid can't be deleted if it
   contains a signal?
[478: Thu Aug  1 13:27:31 2024
DONE :478] - Make more to-do

:469]
[472:

Thu Aug  1 12:08:13 2024 Looks like we already
have FWB.makeTemp()..

:472]
[477:

Thu Aug  1 13:23:47 2024 OK we're ripping along
today..

TODO
[495: Sat Aug  3 10:40:42 2024
DONE :495] - Get TAPs to look for Axon endpoints and
   potentially inject/extract signals
[496:
DONE  :496] - Get HDGF to inject its result
[497: Changed to MLRF instead but
DONE :497] - Get GRIP to extract and report HDGF signals
[498:
DONE :498] - Get Axons to propagate signals
[499:
DONE :499] - See signals moving through an Axon
[502:
DONE :502] - Come make more to-do

:477]
[479:

Thu Aug  1 13:54:59 2024 So, we have TermHidden
but so far nobody is using it. Our HDGF 'hidden
unit' for example,
 is-a HOpDiff
  is-a HOpBinary
   is-a HOpArgsT(2u)
    is-a TermHOp
     is-a TermMotor (is-a TAP)

and TermHidden is nowhere in there..
[480:

Thu Aug  1 14:22:01 2024 So, where shall we inject
this 'Axon searching' step?

..Well, how about TermHOp, for now? Well but then
GRIP won't use it, for one thing.

[481:

Thu Aug  1 14:40:01 2024 Put it all the way up in
TAP? But make it an optional service? Maybe I
guess.
[482:

Thu Aug  1 18:22:20 2024 OK so it looks like we
have mTapFound getting set plausibly.

I guess we need to get TAPs to notice the AxonEnds
and do something with them..

:482]

:481]

:480]
:479]
[483:

Fri Aug  2 03:44:12 2024 Do we want to use
handleSigHook(..) to get updateHOp(..) called?
What does a hidden unit do with a result.. and
when does it do it?

Nap time.

:483]
[484:

Fri Aug  2 09:27:59 2024 OK so TermHOp is
executing on the sig hook, and now we need to
inject the result into an axon if an appropriate
one is present.

:484]
[485:

Fri Aug  2 11:19:35 2024 OK so as usual I'm
getting myself all twisted up between axon head vs
tail and signals outbound vs inbound and which
SlotSig gets which and so on.

What can we maybe say to try to clarify things?

 mAxonTaps[cAXON_HEAD_IDX] is the tapidx, if any,
   at the head of the entire axon
 mAxonTaps[cAXON_TAIL_IDX] is the tapidx, if any,
   at the tail of the entire axon

TapIdx getAxonTap(AxonIdx idx) returns an
mAxonsTaps[idx], if there is one, else cTAPIDX_NONE


 For an AxonHead, getAxonIdx() returns cAXON_HEAD_IDX
 For an AxonTail, getAxonIdx() returns cAXON_TAIL_IDX

 For an AxonEnd, then, getAxonTap(getAxonIdx())
 should always be either cTAPIDX_NONE, or the
 tapidx of the TAP nearby the AxonEnd.

[486:

Fri Aug  2 12:34:16 2024 And so if

 - a TAP finds an AxonEnd with a matching
   getAxonTap(getAxonIdx()), and
 - the TAP has an outgoing signal, and
 - !axon.mAxonSigs[getAxonIdx()].isOccupied()
 - then the TAP c/should inject the signal into
   that mAxonSigs.

On the other hand, if
 - a TAP finds an AxonEnd with a matching
   getAxonTap(getAxonIdx()), and
 - axon.mAxonSigs[1u-getAxonIdx()].isOccupied()
 - then the TAP should consume the signal from
   that mAxonSigs (probably, whether it wants to
   use it or not.)

[487:

Fri Aug  2 13:16:01 2024 So, are those two
functions we ought to be making here?

 Bool TAP.trySendSig(Axon & axon, SlotSig & outsig)

 Bool TAP.tryRecvSig(Axon & axon, SlotSig & insig)

 SN TAP.findMatchingAxon()
     - a TAP finds an AxonEnd with a matching
       getAxonTap(getAxonIdx())..

[490:

Fri Aug  2 15:13:56 2024 OK so now we have visible
sigs moving through the axon and clogging up at
GRIP because we still don't have a receiving
process set up.

When do we try to receive from axons? Probably
should be around the time we try to receive from
the xb?

:490]

:487]
:486]

:485]
[488:

Fri Aug  2 14:27:03 2024 Woah looks like we might
have outbound hidden unit results propagating.
Quick need

[489: Fri Aug  2 14:35:48 2024
DONE :489] - AxonMid color change on sigs
[492: Sat Aug  3 03:13:38 2024
DONE :492] - Consume axon sigs

:488]
[491:

Sat Aug  3 03:13:53 2024 Well so some progress.
Signals are getting generated in a hidden unit in
one xb, sent through an axon to a motor unit in a
different xb, and getting extracted from the axon
when they arrive.

Current step is I'd like to suppress sending 0s
from (in our demo spike) HDGF to MLRF, but I'm not
sure where to do that.

Nap now.

:491]
[493:

Sat Aug  3 09:10:21 2024 OK! So we have now seen
the very first instance, in the history of the
universe, of the grey sensors actually affecting
Beevee's visible behavior.

Of course, it was affecting it entirely in bad
ways, but that's absolutely par for the course.
The control's the thing. The signs we can fix..

We can see Beevee twitch and change direction
slightly, when it passes over an checkerboard
boundary with one (front) wheel but not the other.

[494:

Sat Aug  3 10:37:21 2024 OK so I think maybe the
next thing to do is disarm the whole grey branch
except in TRAVL mode (or let's put it in EXPLORE
for now, as easier).

Also reduce the scale a bit.

We really need to deal with getting FloodFind
>[503:   :503]working, and get these axons set up automatically.
We're still initting it by hand at the moment.

Can we claim some to-dos first?
[501:

Sat Aug  3 10:42:32 2024

TODO
 - Demo FloodFind finding something

:501]
:494]
:493]
[504:

Sun Aug  4 08:14:38 2024 FloodFind state
transitions

Me     Parent    Actions
FLOOD  FLOOD     search -> FLOOD,FOUND
FLOOD  FOUND     me<-PRUNE (someone else found it)

FOUND  FLOOD     parent<-FOUND, me<-TRACE
FOUND  FOUND     me<-PRUNE (someone else beat me to it)
FOUND  TRACE     me<-PRUNE (someone else beat me to it)
FOUND  (none)     (root) prune all non-trace kids? prune excess found, parent<-trace

PRUNE    *       kids<-PRUNE; me die

TRACE    *       (wait to be consumed by axon?)
[505:

Sun Aug  4 09:12:14 2024

               [ME]
                 FLOOD        FOUND      TRACE      PRUNE      DIE
 [PARENT]                                                     +-----+
    DIE           (wait)      (wait)     (wait)     (wait)    |die()|
                                                              |     |
                                                  +--------+  |     |
    PRUNE         (wait)      (wait)     (wait)   | prune()|  |die()|
                                                  |        |  |     |
                                                  |        |  |     |
    FLOOD        search -?    p<FOUND    faildie  | prune()|  |die()|
                    m<FOUND   m<TRACE             |        |  |     |
               +----------------------+           |        |  |     |
    FOUND      | m<PRUNE      m<PRUNE |  (wait)   | prune()|  |die()|
               |                      |           |        |  |     |
               |                      |           |        |  |     |
    TRACE      | m<PRUNE      m<PRUNE |  (wait)   | prune()|  |die()|
               |                      |           |        |  |     |
               |                      |           |        |  |     |
    non-self   | m<PRUNE      m<PRUNE |  (wait)   | prune()|  |die()|
               +----------------------+           +--------+  +-----+

prune() ==> set kids to PRUNE; erase self
die() ==> set kids to DIE; set parent to DIE; erase self
[506:

Mon Aug  5 01:02:54 2024 Well, that state diagram
helped implementation a lot, and FloodFind is
pretty kinda working now.

I really want to reorganize the whole brain layout
system but there just isn't time. I think I need
to hack in a mechanism to release some of these
floodfinders as part of hidden unit operations.

:506]
:505]

:504]
[507:

Fri Aug 16 00:12:50 2024 Yikes nine days. I have
started working again but for some reason really
didn't want to come back to start notes again.

So, we're making scripts/makeBeeveeSources.py to
generate BeeveeXB.ulam to represent a pile of xbs
laid out in a(n HC3) coordinate space.

We're at the point of needing to figure out the
in/sensor and out/motor layouts on the different
possible sides of the xb. We're thinking that we
should number both in and out starting from their
mutual corner.
[508:

Fri Aug 16 01:41:53 2024 I guess if we factor out
in-vs-out, there's only the four corners as
'origin' for a total of four cases.

[0,0]                             [w-1,0]
      (+1,0)->        <-(-1,0)
     NW                      NE
  (0,+1)                   (0,+1)
    |                        |
    v                        v

    ^                        ^
    |                        |
  (0,-1)                   (0,-1)
     SW                  SE
      (+1,0)->        <-(-1,0)    [w-1,h-1]
[0,h-1]


:508]

:507]
[509:

Fri Aug 16 08:19:49 2024 OK now we're at the
question: Is a corner C2D in both edges it touches
or not? Which is related to: Are we going to use
the actual corner at all, or have the 'edges' run
between the corners but not include them?

I'm like:
 - we should not use the corners, because it's a
   cleaner separation of 'edge' vs 'field' in the
   xb.
 - but we currentlyh ARE using the NW corner, at
   least, for the GRIP in the hotbox.
 - but only one TAP can use a given corner so
   using it introduces an asymmetry
 - but CAN only one TAP use a given corner?
 - SHUDDUP SSHUDDUP ONLY ONE TAP CAN USE A CORNER

[510:

Fri Aug 16 08:29:12 2024 Let's try to see about
not using the corners, maybe? Like maybe:

      (0,0)   SRLY    SLLY    TOCK   (4,0)

      MRRF     .       .        .      X

      MLRF     .       .        .      X

      (0,3)    X       X        X    (4,3)

[511:

Fri Aug 16 09:09:32 2024 So that *ould involve
things like:

 - index the in/out vectors starting at 1
 - expanding w and h by 2 over the contents
 - taking up more space in the hotbox..
[512:

Fri Aug 16 09:34:31 2024 urrrgh. If we wanted to
go the asymmetric route.. urrgh.. could we always
give the corner to, say, out?

So that *ould involve things like:
 - having separate 'offsets' of some kind for in
   and out

..but one thing we liked about not using the
corners was having a clear place for 'X'
anchors/sinks opposite the in and out vecs.. and
since we currently have that bug with stuff
growing the wrong way sometimes, and gluing
separate xbs together.. well not sure.
[513:

Fri Aug 16 16:34:39 2024 Well, it looks like we
finally have utterly untested but fairly complete
code for the new xbinfo / xbinfomap scheme. What
do we still need?[514:

Fri Aug 16 16:45:31 2024 I guess we need code to

 - call XBInfoMap.getContainingXBIndex, and then 
 - call XBInfoMap.getXBInfo(idx,xbib) if alive

[515:

Fri Aug 16 16:48:41 2024 hmm it looks like we want
to check on inbound and outbound taps separately,
but the code we're generating folds them
together. Let's fix that first.[516:

Fri Aug 16 16:54:03 2024 OK now we changed the API
  ClassId XBInfo.getXBInfoTAP(C2D relc, Bool sensor) 
and we'll see how that goes.
[517:

Fri Aug 16 16:55:24 2024 So maybe we want
XBarSpace2DState to have a BeeveeXB in it??

Getting to be time to break for dinner prep.
[518:

Fri Aug 16 22:44:16 2024 OK OK OK OK it's time to
hook up this new stuff and see what esplodes
first.

So, the existing XBS2DS.makeTAP is using
TermTargetLibrary to get brain info. That's at
least one place we have to redo..[519:

Fri Aug 16 23:26:52 2024 OK implementing..
currently in a newXBInfo.makeTAPInstance(..) and
realizing we need to derive the 'XBSSy' value from
the indir and outdir as well..[520:

Fri Aug 16 23:43:08 2024 Buut is this really
enough info at this point -

  //// XBar Source Symmetry
  typedef Unary(2) XBSSy;
  constant XBSSy cXSH = 0u;     //< Xbar Sensors Horizontal
  constant XBSSy cXSU = 1u;     //< Xbar Sensor orientation Unknown
  constant XBSSy cXSV = 2u;     //< Xbar Sensors Vertical

? What's the XBar bit budget at, again?[521:

Fri Aug 16 23:44:42 2024 70b used, 1b available
urrrgh.. [522:

Fri Aug 16 23:55:35 2024 In this context, we do
also suspect that this XBSSy stuff is involved in
the inter-xb crossing bugs we saw during
'robustness testing'.

If we used an event window symmetry instead - or
the moral equivalent - we'd take 3b and wipe out
the budget entirely, but then we could have 2b for
corner x 1b for sensorscw vs ccw.
[523:

Sat Aug 17 00:27:10 2024 How is XBSSym currently
used? [524:

Sat Aug 17 00:28:10 2024 Well, it transfers to

    Bool TAP.mSenseVert;

in TermTager.makeTAPInstance(..)

..and it's copied to TermTarget.mSBSSy in
TTL.getTermTarget(..) [526:

Sat Aug 17 09:54:35 2024 ..and mSenseVert
transfers (back?) to xb.mSymmetry in
xbs.stabilize(..) [527:

Sat Aug 17 09:57:12 2024 And it's also used there
to init the xb.mTaps[cW/cE] or cN/cS, which is
something I kind of actually understand finally.

I'm really thinking we'd like to scrape up 3b in
the xb and store corner + rotation... and then we
wouldn't even need mTaps[4]? Is that
possible?

:527]

:526][525:

Sat Aug 17 09:41:16 2024 I guess it's partly a
question of how mSenseVert is used.. but I'm
tempted to think we could just store the origin
corner and work from that.

:525]

:524]

:523]

:522]

:521]

:520]

:519]

:518]
:517]
:516]

:515]

:514]

:513]
:512]

:511]
:510]
:509]
[528:

Sat Aug 17 10:30:17 2024 OK so here's the thing:
With the newe 'XBInfo' and 'XBInfoMap', basically
the whole brain is statically pre-specified down
to exact coordinate positions. So we absolutely
could, as a random xb, answer questions like
'In my xbar, which side are inputs coming from,
and what TAP sensor is out there?' directly by
querying the BeeveeXB struct, with no propagation
of any kind required.

But that's really awful. It's vastly increasing
the leverage hanging off of the HC3 diamond
coordinate system; welding everything together
into one huge high-order crystal hanging off the
single point of failure HC3 root.

[529:

Sat Aug 17 10:55:59 2024 But how do we split the
difference? Where do we switch from global to
local? Maybe we should run with the global, this
time, flat out, all the way,, to understand its
pros and cons better? Like in a new branch or so?

urrrrrrghhh
[530: 

Sat Aug 17 11:00:20 2024 I guess part of the story
was going to be that the BeeveeXB was 'just for
initialization', and the xbs might get modified
over time, and that's why local propagation would
still be necessary.

But 'healing is initialization', 'building is
rebuilding', and so on.. there's no clear dividing
line.

Sooooo. What's the minimum we can take from
BeeveeXB and just get the existing mTaps/etc
structure going?

[531:

Sat Aug 17 11:26:45 2024 Possibly related
question: We're doing the don't-use-the-corners
approach at the moment, which I think means there
could be room for 'X' 'stoppers' on xb sides that
don't have TAPs. And having such stoppers
might/ought to make the mTaps propagation easier,
right?

[532:

Sat Aug 17 13:41:41 2024 So suppose we 'only' use
BeeveeXB for identifying xb that should have TAPs.
And we can use it, in that context, to determine
which way the mTap info should propagate. Beyond
that, everything remains as it is, mTaps[] and
all. Could we try for that (after nap)?

:532]

:531]

:530]
:529]

:528]
[533:

Sun Aug 18 00:38:32 2024 OK we're finally finally
finally getting to debug something after days and
days and days of design hell. First explosion:

    20240818003811-3287: 2706AEPS [2F9E2D87]MSG: T[1,1]@S[6,21]: behave() failed at /data/ackley/PART4/code/D/BVBrain/code/.gen/src/../include/Un_10139212XBInfo_GREYS10.tcc:173: ARRAY_INDEX_OUT_OF_BOUNDS (site type 0x703F)
    20240818003811-3288: 2706AEPS [2F9E2D87]MSG: BACKTRACE  ->  0: MFM::Un_10139212XBInfo_GREYS10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_9212getXBInfoTAP(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Uq_102323C2D10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Ut_10111b<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) + 0x3B2
     ->  1: MFM::Un_10136XBInfo10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_9215getXBInfoTAPAbs(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Uq_102323C2D10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Ut_10111b<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0x18F
     ->  2: MFM::Un_10423289216XBarSpace2DState10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_7makeTAP(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Ue_r102709211XBarSpace2D10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0x5F6
     ->  3: MFM::Un_10423289216XBarSpace2DState10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_919stabilize(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Uq_r10138Intender10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) + 0x450


:533]
[534:

Sun Aug 18 01:29:49 2024 Well, it's an indexing
thing, and it only happens on xbar.GREYS indir (on
its last element.

What I'm wondering is: Did I really commit to the
asymmetric sides? Where one side gets the corner
and the other side has to be offset by one? I
thought we were going with: Don't Use The Corners,
which would I think mean that the GREYS inputs
should be indexed 1..4, right?[535:

Sun Aug 18 01:45:57 2024 I see, for example:

    // {'uses': {'GREYS': ['in', (-10, -1), 1]}} TAP in SFLG #1 in GREYS at (-10, -1)
    // {'uses': {'GREYS': ['in', (-10, 0), 2]}} TAP in SFRG #2 in GREYS at (-10, 0)
    // {'uses': {'GREYS': ['in', (-10, 1), 3]}} TAP in SRLG #3 in GREYS at (-10, 1)
    // {'uses': {'GREYS': ['in', (-10, 2), 4]}} TAP in SRRG #4 in GREYS at (-10, 2)
                                          ^^^

suggesting 1..4 are indeed the indexes.

So why aren't we subtracting 1 somewhere along the
way to this point?[536:

Sun Aug 18 02:08:01 2024 Ah I think it was just a
typoe off-by-one in getRelBox. Going again.[537:

Sun Aug 18 02:35:12 2024 OK that's fixed.

Next problem is an offshoot of our 'clean'
Don't-Use-The-Corners decision:

  When an outbound signal is first created, it
  used to see a inbound cross street. (Because we
  gave the corner to the first motor.) It might or
  might not be interested in that inbound, but the
  fact of its existence meant the sig could
  propagate onwards.

  But now with empty corners, there's no inbound
  cross street at the beginning, so the signal
  gets consumed immediately, thinking it's at the
  end. 

[538:

Sun Aug 18 02:49:38 2024 So we need some kind of
kick start there, it would seem.

We also had the thought that empty corners means
we could have explicit xb edges, which could
interact with this because, if we had some
confidence we'd get told when to stop, we could
just propagate whether there was a cross street or
not.

Maybe. Or belt and suspenders.

:538]
:537]

:536]

:535]

:534]
[539:

Sun Aug 18 10:14:17 2024 gah so I'm trying to do
"output gets the corner" after all.. after trying
"empty corners" and getting screwed by propagation
stuff at several places in the code.

And now I'm getting screwed trying to figure out
how to represent the eight cases of "which
corner?" X "which side is output?" in any kind of
slightly non-disgusting way.
[540:

Sun Aug 18 10:41:18 2024 aaaand now I'm thinking I
should stick with empty corners and deal with the
kickstarting in all the different places in the
code.. because, doh maybe, I'd like to have a
potential for reversing xb direction down the
road.. without reconfiguring geometry..

[541:

Sun Aug 18 10:53:50 2024 How many places would we
have to hack? It feels like just about every place
the code mentions cTAPIDX_NONE..[542:

Sun Aug 18 13:36:55 2024 Places to deal with

 - Router.ulam:67 trySwitch looking for tap sink 
 - Router.ulam:130 tryOutboundPropagation looking
   for cross-street inbound taps (and bailing if
   not)
 - Router.ulam:154 still in tryOutboundPropagation
 - Note: Router.ulam:181 in tryInboundPropagation
   should remain as is (I think..)

(Also note XBarSpace2D.getTapIdxIfAny(Bool)
depends on mSymmetry, which we're unsure about..) 
 

:542]

:541]

:540]
:539]
[543:

Sun Aug 18 17:26:07 2024 Well, so it looks like
the hacked-over empty-corners strategy is working
enough to do the HOTBOX and the GREYS.

:543]
[544:

Sun Aug 18 20:11:47 2024 Might be having an issue
where signals aren't getting consumed at the end
of the GREYS, so the first operand is blocking the
second operand from arriving. I think that's what
it is..

The observable failure is we're not seeing any
signals going through the axons..
[545:

Mon Aug 19 14:52:30 2024 Well it seems that was
due to having HDGR and HDGF inherit from HOpDiffNZ
instead of HOpDiff.. so we just didn't happen to
see those rare moments when both L and R were
changing.

But now stuff is semiplausibly working.

:545]

:544]
[546:

Tue Aug 20 09:32:14 2024 Stuff transferred from
202408170040-fresh part:

    PROMPT: BEEVEE TRACKS THE GRID

    PLL to track edges
    maxcount (freq) and
    curcount (phase)

     -> note that all four grey sensors can contribute
        to the SAME freq estimation, just with each
        their own phase!

and summarizing now:

 - Current scheme can't work because no way to
   distinguish leading edge from following edge;
   it's all basically linear. 'Leading' left edge
   accelerates the right, but the 'following'
   right will accelerate the left again.

 - To distinguish leading from following we need a
   notion of a cycle, with a beginning and an
   ending, so we can say leading vs following with
   respect to the current cycle, and break the
   symmetry that way.

 - The 'obvious' way to get a cycle is build
   software Phase-Locked Loops to estimate them,
   and that's the 'big insight' for next steps.

[547:

Tue Aug 20 09:38:43 2024 And noting we want to
estimate on-period and off-period to get the full
cycle-period, because they won't be equal in
general and that's good information to know.

mCycleWidths[2]; // [0] light, [1] dark
mCurrentPhase;   // 0..(wid[0]+wid[1]-1)

 maybe transition light->dark at 25% and
 dark->light at 75% or something. Or 0% and 100% I
 suppose. 

[548:

Tue Aug 20 10:01:23 2024 Now, that's going to take
some significant bit budget, isn't it? If we're
really grounding out in individual events? I'd
think we'd 16bx3 anyway?

Or can we be counting in terms of spine updates
instead of events? We have that ability right?

Couldn't we rough something up to gather sample
data and get some kind of idea where we're at?

:548]

:547]

:546]
[549:

Tue Aug 20 16:29:58 2024 OK moved the flag.

[550:

Tue Aug 20 17:19:24 2024 A while ago I increased
the checkerboard grid size but now I'm wondering
if I should shrink it again -- in hopes of having
more cycles and shorter cycle widths to converge
the PLLs more quickly and robustly.

Do I even know how to change back?[551:

Wed Aug 21 02:19:49 2024 OK I think it's changed
back.. The squares look awful small now.. but we
do get reasonably frequent edges when beevee is
cruising.

Thinking we should only update the PLLs when we're
in TRAVL (or HUNTR as we're doing it atm.) We'd
still like to count edges in other modes but
that's got to be advanced.

[552:

Wed Aug 21 02:28:57 2024 So. We need some steps
here pronto.

[553: Thu Aug 22 15:36:50 2024 well, anyway
DONE :553] - Only update PLLs when blue
 - extend .cfg notation to allow multiple TAPs of
   the same type in an xbar. Any such get handled
   uniformly for routing, but can be distinguished
   by.. something.. for 1-1 purposes?
   = or is that just subclassing and we should own
     it and the proliferation it has already
     brung?

:552]

:551]

:550]

:549]
[554:

Thu Aug 22 15:37:05 2024 OK so we're at like do or
die for some course-correcting signal processing
here.

So now we have four instances of HOpPLL10, one for
each grey sensor. They are extremely aggressive
and flop all over the place, which I think is
possibly for the best since the signal they're
"tracking" is going to be highly variable anyway.

Among the ideas about what we might try to do with
them:

 - Send some front left and front right state to
   another unit and have it generate kicks somehow

 - Send some state from all four grey sensors to
   another unit and have it estimate a combined
   frequency from all of them.

[555:

Thu Aug 22 15:43:23 2024 What state could front
left and right send to help generate kicks?[556:

Thu Aug 22 15:48:02 2024 We could send like 1 bit
of current state plus seven bits of unsigned
current phase. At a minimum we could send only
when the current state changes, or at most I guess
once every on every arriving grey sensor signal.

[557:

Thu Aug 22 15:52:55 2024 We need to get some axons
out of these 'pll's I guess, and we need to send a
sig down the axon at the point we are currenlty
doing

        du.print("STSHDGF10");

How do we ask for axons, again? And, where should
these axons go, exactly?[558:

Thu Aug 22 16:00:19 2024 Hmm. There's a cAXON
array in TermTarget(Library) that we currently
have no analogue for in the .cfg file.

What might that look like?[559:

Thu Aug 22 16:02:11 2024 Well, I guess given our
continuing (but still forlorn) wish to NOT tie
absolutely everything to classids, we might want
to have axon definitions be at the xbar level
rather than the tap level.

Or, perhaps we could make some kind of 'dotted'
notation for TAP-inside-XBAR or XBARs.TAP and then
we could list axons with the TAP

Or we could have a whole toplevel axon section
that lists pairs of TAPs to be connected..

:559]

:558]

:557]

:556]

:555]

:554]
[560:

Thu Aug 22 16:11:22 2024 Well, so we can't really
have 'dotted' notation because toml doesn't have
it, so the obvious thing would be a list - instead
of [MBAR, MFOO, MFOO, MGAH] it could be like

  [MBAR, [MFOO, left], [MFOO, right], MGAH]

or something. But I'm wondering - what about
drafting '_' for this? Something like

  [MBAR, MFOO_left, MFOO_right, MGAH]

or

  [MBAR, MFOO_1, MFOO_2, MGAH]

since '_' is legal in toml identifiers but we're
not making much use of it in the context of TAP
names.. [562:

Thu Aug 22 21:17:46 2024 So is any of this really
executable? We'd need

 - a place to store these named things
 - routines to split and join them
 - a way to identify them in the ew, so we can
   know who we're supposed to hook up with

which means a tapidx isn't enough, we'd need
tapidx + vector idx or counter or global name
disambiguator or whatever. [563:

Fri Aug 23 01:43:15 2024 We could maybe argue that
only FloodFind would need to distinguish repeated
types, while Axon could just carry the tapidx as
before, and count on FloodFind putting the
destination end in the Moore or VN ngb of the
specific intended target.[564:

Fri Aug 23 07:58:08 2024 So, once again, where are
we here? Do we just proceed with unique types? Do
we take the _1 idea and just send it into ulam
directly:

  HFOO_1 : TermHOpFOO
  HFOO_2 : TermHopFOO

[565:

Fri Aug 23 08:00:08 2024 Well, one thing is maybe
we should generate a replacement for
ttl.cTARGET_IDS and friends, at least. And that
would be a reason to add tap entries to the cfg.

Maybe let's try for that, to get ourselves going
this morning..[566:

Fri Aug 23 08:02:45 2024 Except, wait: Those are
all already defined in the PyBulletTime config
file. Well, not the hiddens..

Could we try to load sm216.toml (e.g.) as well as
the BeeveeXB.cfg file, and generate the full table
'properly'? That'd be nice.

:566]

:565]
  

:564]

:563]

:562][561:

Thu Aug 22 21:17:23 2024 Kamala Harris finished
her acceptance speech.

:561]

:560]
[567:

Sun Aug 25 02:32:07 2024 OK so we reduced the
overall LocalSpace2D to 6b coords instead of 7b,
and thus managed to expand the TapIdx from 5b to
6b, so we can go over 32 TAP distinct taps.

6b coords makes the diamond a lot smaller, but it
still looks like it has plenty of space for the
kind of things we're imagining now.[568:

Sun Aug 25 04:55:14 2024 OK, so now we're dying
because we've added a bunch of new TAPs that
TermTargetLibrary doesn't know about.. because we
want to write around/out TTL in favor of
BeeveeBIM.
[569:

Mon Aug 26 08:17:44 2024 OK, we spent a long time
debugging stuff but now we've got a weirdly
rotated xbar seeming to set up correctly, and
we've moved most functionality out of
TermTargetLibrary and into BeeveeBIM. I think we
have, anyway.

So, now I think we're back to axon routing. We
want some syntax for the dtoml to specify which
taps should connect out to which.

I think maybe I want to put these decls into
specific XBInfos, rather than the BrainInfoMap as
a whole?

Because why? To have some hope of breaking the
element-type-per-TAP stranglehold we're currently
dealing with? So axons could be disambiguated by
the particular XBar involved?

But what if we want to do some odd-hack
connections between free-lance TAPs?

We don't have any such thing atm but we're
expecting to start chafing under the 'have to
create a new xbar for that' regime we've made for
ourselves..[570:

Mon Aug 26 08:40:08 2024 Well okay for now I've
just made an 'axons' key for xbars, like:

    [xbar.GREYS]
 ..
      inputs=[SFLG, SFRG, SRRG, SRLG]
      outputs=[HFLG, HFRG, HRRG, HRLG]
      axons=[[HFLG,IFLG],
             [HFRG,IFRG],
             [HRRG,IRRG],
             [HRLG,IRLG]]

and now we need to generate some code from that.
How does TermTargetLibrary deal with axons?[571:

Mon Aug 26 08:45:52 2024 Looks like a scalar per
TAP giving the tapidx of the axon dest, or
cTAPIDX_NONE for no axon. Plus this:

  TapIdx getAxonDestTapIdxFromTapIdx(Unsigned tapidx) {
    return cAXON[tapidx]; // or fail if tapidx >= cTARGET_IDS.lengthof
  }

as api. So we could do that in BIM land,
  right?[572:

Mon Aug 26 14:03:38 2024 Well, I made

  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {

but at the moment it's per-XBInfo and that's not
very convenient for caller..

But I really don't want to rule out having
multiple uses of a given tapidx. So how could that
be resolved without going to XBInfo level?

Could we make it easier for caller to find the
appropriate XBInfo instead?[573:

Mon Aug 26 14:19:13 2024 If we made

  virtual Bool handleSigHook(SlotSig & iss, Unsigned gripnum)

be more like

  virtual Bool handleSigHook(SlotSig & iss, GripSource & grip)

then we could dig out the absc from the grip
source and go that way..

:573]

:572]

:571]

:570]

:569]

:568]

:567]
[574:

Tue Aug 27 01:14:24 2024 OK so question: What
signal does a HOpPLL10 produce when it executes?
Right now HOpPLL10.execute(..) is just returning
false, so we never want to ship anything so we're
not entering the axon shipping code.[575:

Tue Aug 27 01:25:05 2024 I guess we want the 1b
state and like 7b time-in-state? Let's try it I
guess. Then we'll need a HOp that takes two of
them and turns it into motor deltas..

:575]

:574]
[576:

Wed Aug 28 01:43:57 2024 OK so the current bug is
a bit of a design mess, involving the whole xbar
'symmetry' concept I made up to try to generalize
xbs using only two bits.

It involves, at least, the xb slotsigs - 

  SlotSig mSigs[2]; // [0] column (default outbound), [1] row (default inbound)

where the 'default' comments are strongly the way
I was thinking about them.. as outbound and
inbound, not as columns and rows. I'm not sure how
much code may have that assumption build in, also. 

But in xbar.CTLGREY it goes the other way -

    [xbar.CTLGREY]
      indir=E
      outdir=N

an east indir means the outbound sigs move west
along the rows, so that should be mSigs[1], and
north outdir means the inbound sigs move north
along the columns, so mSigs[0].

I guess we have to trace the whole damn flow with
this in mind..

:576]
[577:

Wed Aug 28 11:26:42 2024 So ohhhhkay. We are
talking about an outbound signal from IFLG,
sitting in mSigs[1] of an XBarSpace2D. That XB, in
turn, is in the East column of CTL_GREYS.

Also, that XB has mTaps set as thus:

 mTaps=[0]=63/0x3F/'?',[1]=63/0x3F/'?',[2]=63/0x3F/'?',[3]=19/0x13,

in other words, mTaps[East] is 19, for

    IFLG.classidof,  //< 19 sensor IFLG

and everything else is cTAPIDX_NONE.

Also, that XB has mSymmetry set to 2, 'meaning'

  constant XBSSy cXSV = 2u;     //< Xbar Sensors Vertical

(and it happens to be in (-17,0) of the HC3
diamond.)

[578:

Wed Aug 28 11:39:59 2024 Hmm could the bug be: We
didn't relabel the sig to change its mSource
(currently set to 28/HFLG) to 19/IFLG? So the 'go
away from our sig source' wouldn't work?
[579:

Wed Aug 28 11:53:20 2024 I think that is it.
Letting go of this state and going again.
[580:

Wed Aug 28 12:20:43 2024 OK, that was it.

Next 'bug' is the relabeled sigs aren't switching
onto the inbound lines. I think that's probably
because there's just some (distributed, ugh)
configuration that we need to configure but
haven't. So let's review that. Where are switching
decisions expressed?[581:

Wed Aug 28 12:30:36 2024 Looks like it's

  /** \return true to request switching the sig (modifying \c slot to
     the result of the mapping if needed), false to reject switching
     to this \c out
   */
  Bool Router.mapSig(SlotSig & slot, TapIdx out, TapIdx in, XBarSpace2D &xb, XBarSpace2DState & xbs) 

that governs that.

And in turn, that goes to
GripInfo.getDestinations(outboundtapidx) to get a
list of inbound tapidxs that want the signal.

So this is the whole GripInfo.SenseDests business.
Where are they defined?[582:

Wed Aug 28 12:34:31 2024 So, right now, he said
incredulously, we're modifying code inside the
GripInfo quark for (basically) every change in
routing? [583:

Wed Aug 28 12:51:35 2024 OK, so, yeah, that's what
we're doing (gah) and now sigs are reaching the
(alleged) phase difference calculators HPDF and
HPDR, and the (alleged) frequency averager HFQA.

None of which are currently computing anything, at
the moment.

:583]

:582]

:581]

:580]

:579]
:578]

:577]
[584:

Wed Aug 28 23:51:57 2024 Hey what about if in red
mode, we ratchet the eyestalks out wide? To keep
us in red mode until we're fairly well clear of
the red. Hmmmmmmmmm. Seems plausible at least..
[585:

Thu Aug 29 01:02:29 2024 How hard would it be to
find where that intervention might go?

:585]

:584]
[586:

Fri Aug 30 02:37:44 2024 OK so we 'went wide' on
red and that does seem like plausibly an
improvement.

But we still haven't implemented the phase
difference stuff, and we still haven't figured out
what to do about how to transmit phase and
frequency info in an eight bit signal.

[587:

Fri Aug 30 02:41:25 2024 Last I recall we were
wondering about ditching (or repurposing) the
CTL_GREYS xbar and somehow placing phase
differencers 'close' to their sources, instead of
around an xbar corner?

:587]

:586]
[588:

Fri Aug 30 02:50:37 2024 What if we sent 1 bit of
current state + 7b of timeInState/2 ?

..and did what with it?

Suppose we saved it in a HOpBinary, and when we
have both ops we do something.

Brilliant, Chumley, brilliant.

I mean, if their states are the same, but their
phases are significantly different, we send a
little 'slow down' hit to the leading wheel (the
one with the *larger* phase?)
[589:

Fri Aug 30 03:33:00 2024 Conceivably, even if the
states are different, we do the same thing? Just
send a slow down to the larger phase, unless
nearly the same?

But then we get the symmetry back to kill us.. at
the instance the leading corner crosses an edge,
suddenly it's the much smaller phase, and we start
undoing the corrections we were just making.

So, if the current states are different, we do
nothing? Nahthink?

Still might accomplish something?

Or, if the current states are different, do the
reverse? Send a slow down to the notably smaller
phase? That would cause them to pile up instead of
canceling out..

muuuhhhaaaaayyybee.

[590:

Fri Aug 30 08:49:42 2024 OK, so we have quark
HOpPhaseDiff to try and do this, and we have the
state and phase info extracted from a pair of
sigs, and that all looks plausible enough. When
Beevee's traveling fairly but not perfectly
straight down the checkerboard I'm seeing a phase
difference of around 20, which seems plausible
enough.

I've also rearranged xbar.GREYS and xbar.CTLGREY
to put CTLGREY on the right and so a bit closer to
the xbar.HOTBOX.

What A Joy To Do That By Changing Only Two Numbers
And Rebuilding. Thank You Me. Big Fun Oh Yay.

[591:

Fri Aug 30 08:55:10 2024 So, now we 'just' need a
signal to send to the motors. What are the motors
getting so far?[592:

Fri Aug 30 09:02:12 2024 They appear to be getting
a constant value 50 from TOCK (mapped to signed
ASCII). (Which somehow gets divided by 4 by the
time it actually hits the wheels, producing 12.5
wheel speed during EXPLORE.

So what if we just did like hits of 16 perhaps, to
inject wheel 4 for adjustments. Or 32 maybe.

Let's see if we can get axons built for this,
anyway.. [593:

Fri Aug 30 09:36:56 2024 Well, currently stuck in
NORED so not seeing axon growth attempts.. but I
kind of suspect it won't trigger until we try to
push something out..

[594:

Fri Aug 30 09:42:19 2024 So hey, just shifted
CTLGREY to output out the south and It Worked
First Time And Was A One Byte Change. Fun![595:

Fri Aug 30 12:28:48 2024 OK, so we have now sent a
constant test signal from HPDF to MLRF, at the
'appropriate time' for sending a real signal.

And, furthermore, we have seen the effect of the
test signal showing up in wheel vehicle signals.

So now we really really need some actual signal to
send instead.

Now, our idea was going to be that if the
difference was small enough, we should do nothing.

How about +-5 for a first cut. WTF.[596:

Fri Aug 30 12:33:40 2024 Now. We just wrote this:

    Int pdiff = (Int) lPhase - (Int) rPhase;
    if (pdiff >= -5 && pdiff <= 5)
      return false;

so pdiff is positive if left phase is bigger,
which means left edge is behind, which means we
should want to accelerate left wheel. Does that
seem right?

So what if we took like pdiff/5 or so, and added
that to 50 -- the (now-declared to be) default
explore running speed, according to
TOCK.switchSigVal(..), and intToSignedAscii that?

[597:

Fri Aug 30 12:42:16 2024 Let's DO ITTTTTTT!

:597]

:596]

:595]

:594]

:593]

:592]

:591]

:590]
:589]

:588]
[598:

Mon Sep  9 12:06:56 2024 OK, starting to review
grip stuff prior to trying to add a new ORIENT
grip.

Facts
 - We are now at Unsigned(3) for grip numbers, so
   7 possible

 - 4 grips are already declared

  constant Unsigned cGRIP_HUNTR = 0u;
  constant Unsigned cGRIP_BV2BY = 1u;
  constant Unsigned cGRIP_NORED = 2u;
  constant Unsigned cGRIP_TRAVL = 3u;

   but we don't think TRAVL is actuall doing
   anything. We think we could rename it ORENT or
   something maybe.
[599:

Mon Sep  9 13:24:40 2024 Now, where-all are the
grip implementation details scattered, and can we
consolidate them somewhat in some sensible way?

WHERE IS GRIP INFO USED? --
[600:

Mon Sep  9 13:26:14 2024 Well maybe let's back up
to just ask ourselves what the GripInfo API talks
about, before trying to figure out where-all the
api is implemented.

GripInfo has primarily these:

      virtual ARGB getGripColor(Unsigned selector) ;
      virtual String getGripName() ;
      virtual SenseDests getDestinations(ClassId forSensor) ;
      /** modify \c value in place, \return true to ship the signal, false to dump it */
      virtual Bool mapSourceSignalValue(ClassId forSensor, ClassId forDest, ASCII & value) {
        return true;                // default: ship with identity map
      }
      virtual Unsigned getNextGripNumber(GRIP& grip) ;

with

      typedef ClassId SenseDests[4];

to determine routing of signals in an xbar fabric,
and

      /** modify \c value in place, \return true to ship the signal, false to dump it */
      virtual Bool mapSourceSignalValue(ClassId forSensor, ClassId forDest, ASCII & value) {
        return true;                // default: ship with identity map
      }

to do what that says.. which kind of seems to
generalize/overlap with getDestinations(..) a bit.

:600]
:599]
:598]
[601:

Thu Sep 12 09:57:21 2024 So okay. We have a
semiplausible 'green sun' plus green detectors and
another xbar to generate green diffs.

[602:

Thu Sep 12 15:50:39 2024 And have we done our grip
review? No we have not. Do we even have a plan for
our new ORENT grip's behavior, independent of how
we implement it? NOT REALLY.

Let's give that a try.

USE CASES AND SHIT FOR THE ORENT GRIP
 - Face to the east
 - Rotate a certain number of spine events cw or
   ccw, to achieve an approximate heading relative
   to east.

So there's some 'sequentialness' to this thinking
because we may need to do a spin until we can see
enough green to hillclimb on.

We also need to control the wheels pretty much
entirely without interference from other sensors.

I guess we could do the 'spin' all integrated with
the 'hillclimb', really, if we just said 'turn
left if no green'.

So that makes this 'sequentialness' less of an
achievement, but it's easier..

I'd like to imagine a GreenGRIP separate from
GRIP, though, if we could, given we want to stay
out of the hotbox as much as possible.

ORENT
 - State: next state?

what if we said ORENT was JUST face to the east?
Like if we start to proliferate grips here, rather
than going for a few giant ones.

So some external thing would switch us to ORENT,
and supply the 'return' grip to go back to once
we're ORENTd?

Could we come up with a test for that?

I guess we could make a trigger element to plop
down for it.

[603:

Thu Sep 12 16:22:27 2024 So let's have some kind
of plan here.

 - Review damn grip stuff
 - Make a list of known tasks for add-a-grip
 - Consider whether to repurpose TRAVL
 - Make a 'generalized grip control' element
   maybe? That we could use for GreenGRIP but
   maybe other things as well? Probably too much
   to ask.

[604:

Thu Sep 12 16:33:13 2024 Let's make a new one, and
leave TRAVL to be rehabilitated sometime later.

:604]

:603]

:602]

:601]
[605:

Thu Sep 12 16:36:11 2024 So GRIP.behave() does a
lot of custom stuff, and it's not immediately
clear where we might want to break into to get it
to stop doing stuff when we're in a grip that's
being handled elsewhere.

We also might want it to have a watchdog regrip
counter in case something falls off the rails with
a different grip controller.
[606:

Thu Sep 12 16:39:04 2024 GRIP's got 21b so we
could certainly afford some kind of counter.

:606]
:605]
[607:

Sat Sep 14 14:11:03 2024 So, we're working on
'GREG', our Green GRIP driver, and we never really
figured out how-all it was supposed to work so
we're floundering. So now here we are, finally.

I'm imagining outside forces would put us into
GREG, and perhaps configure the grip as well.

Let's say GREG has some little internal grip
state, chosen from like

  cGREG_INIT externally triggered
  cGREG_RSET stop motion and slew eye boxes
  cGREG_FIND rotate CCW (say, always) until green detected
  cGREG_HILL track green diff until signed error small


[608:

Sat Sep 14 14:24:40 2024 What if we had it orient
1.5 times, so we could re-estimate degrees per
spinal event, and then keep turning until we
believed we'd reached the desired heading?

0: capture GOAL heading and NEXT grip
1: set motors off and estimate L & R for N0 events (INIT)
2: set motors to +-turnSpeed until L&R 'small' (RESET)
3:  " , and reset count until R 'large' and L>R+g (MARK1)
4:  " , and count until L & R small
5:  " , and count until R 'large' and L>R+g (MARK2)
      compute degrees/event or whatever from count
      reset heading to 0
6:  " , and increment heading by deg/evt until
        GOAL heading reached
7: set motors off and switch to NEXT grip

turning right.

mark 1 when the left and right estimates are both 'small'

keep turning and mark 2 when the right estimate is
'large' and the left estimate passes the 'right'

:608]

:607]
[609:

Mon Sep 16 01:05:45 2024 OK, well, getting pretty
serious about GreenGrip (== GREG) behavior here
and have been wondering how we're supposed to get
commands to the motors. xbar.CTLGREY is already
sending axons to them.. We could have
xbar.CTLGREEN do the same, but it'll be getting
crowded in there.

Wondering about sending an axon from GREG to TOCK
and having it forward them to MRRF/MLRF.

Well fuck it let's just try routing directly and
see how horrible it gets. Can deal with it when we
have to. (We actually already have

    [xbar.CTLGREEN]
 ..
      axons=[[GREG,MRRF],
             [GREG,MLRF]]

but GREG isn't trying to push anything yet so the
axons aren't growning..)

:609]
[610:

Mon Sep 16 01:33:55 2024 OK, we have
diff-of-greens coming into GREG. Now GREG needs to
consume them, and do everything else it needs to
dooooo. 

:610]
[611:

Tue Sep 17 01:09:17 2024 Buuut diff-of-greens
isn't enough - the states in :608: above assume
independent access to L+R greens. So it's redo
time agaaaaaaaain.

:611]
[613:

Wed Sep 18 11:11:25 2024 OK, so I'm trying finally
to get serious about running down all the
signed-vs-unsigned signals issues between python,
c++, and ulam. But we need a fucking plan to go at
that.
[614:

Wed Sep 18 11:23:35 2024 So one idea could be to
declare signed or unsigned in the .dtoml, with
like

    [term.MLEY]
      type=motor
      joint=base_leftstalk
      scale=0.05
      name='Left Eyestalk Angle'
      tile=0
      value=signed     # meaning -128..127

vs like

    [term.SFLG]
      type=sensor
      name='Front Left Floor Grey Sensor'
      tile=0
      value=unsigned   # meaning 0..255


:614]

:613]
[615:

Fri Sep 20 01:01:53 2024 What if we use signed
signals everywhere internally (in the brain) and
map them at the frontier?

Have reading an unsigned TAP automatically convert
the value to signed?

Have writing to a unsigned TAP automatically
convert to unsigned? (We don't have any writable
unsigned TAPs at the moment tho, I think)

:615]
[616:

Tue Sep 24 00:07:06 2024 So lots of work, some
successes, and no notes. Pitiful.

 - The signed/unsigned business is a lot clearer
   than it was, at least, and I have more
   confidence it's doing what I expect in more
   places.

 - 

:616]
[617:

Thu Oct  3 10:06:17 2024 OK well got through t2sup
but it was not great.. Want to remember some
pending wishes for the code:

 - dendritic trees
 - bypass FIFO for binops?
 - check signal collisions in the fabric?
   = blocking? could they be?
 - reperk-up red retreat a bit
   = seeing some bucking again..
   = what is limit on EY turning? [618:
     Thu Oct  3 11:09:04 2024 in motor.py it looks
     like no limit, just heavy scaling from
     dtoml?[620: Fri Oct  4 13:10:58 2024 OK, have
     EYs going wider in NoRed, looks better.
     :620]
   :618]
 - disable blue lane keeping on a timer
   after seeing yellow? (optionally somehow?) 
[619: Thu Oct  3 12:03:40 2024 
 - general proxies to forward signals between xbs
   instead of more types all over the place.
 
:619]
:617]
[621:

Fri Oct  4 13:11:27 2024 Getting ready to shut
down ahead of a sequence of steps to upgrade the
workstation to ubuntu 24.04.1. God have mercy on
our data bits.
[622:

Sat Oct 19 02:27:31 2024 OK it's been over two
weeks and, as 'unfortunately' so often, there's
not a lot of new Beeveeness to show. (There was a
fair chunk other - interesting, unusual, perhaps /
probably helpful stuff - stuff going on, but
still. This file is for Beevee.)

So Where We Are At Now?

 - Very close (I beclaim) to having Beevee running
   on our 24.04 workstation. I believe we just
   need to set up the socat pipelines and stuff.

 - Why don't we just beprove that right now?

[623:

Sat Oct 19 02:34:15 2024 socat installed fine.
[624:

Sat Oct 19 02:37:48 2024 OK, ran:

    root@lcf5820c:~# /data/ackley/PART4/code/D/PyBulletTime/scripts/RootWire.sh 
    MADE RAMDISK
    2024/10/19 02:37:39 socat[1334225] N PTY is /dev/pts/22
    2024/10/19 02:37:39 socat[1334225] N PTY is /dev/pts/23
    2024/10/19 02:37:39 socat[1334225] N starting data transfer loop with FDs [5,5] and [7,7]
    SOCAT RUNNING IN 1334225
    lrwxrwxrwx 1 root root 11 Oct 19 02:37 /dev/ttyS98 -> /dev/pts/22
    lrwxrwxrwx 1 root root 11 Oct 19 02:37 /dev/ttyS99 -> /dev/pts/23
    ^C to exit - 

now I think we're supposed to modify two
Makefile-ish files in two places to put in those
dev numbers..
[625:

Sat Oct 19 02:39:47 2024 OK, I think we want

    DEBUG_DEV:=/dev/pts/22

in PyBulletTime/cfg/Makevars.mk.
[626:

Sat Oct 19 02:40:42 2024 And I think we want

    SERDEV=/dev/pts/23

in T2-12/base/apps/sercon/mfmsserloopRunner.sh
[627:

Sat Oct 19 02:42:01 2024 OK, so t2serloop.py blew
up with 'No module named 'serial'' which I think
means I blew the VENV setup a bit..[628:

Sat Oct 19 02:44:06 2024 OK, with
mfmserloopRunner.sh changed as so:

    #VENVDIR=$SCRIPT_DIR/../../../../VENV/
    VENVDIR=$SCRIPT_DIR/../../../../PyBulletTime/.venv/

it looks like t2serloop.py is up.

Now we should (be able to) run Beevee's H/W?
[629:

Sat Oct 19 02:47:13 2024 Ooooohkayyyy, this
doesn't seem so pleasant:

      File "/data/ackley/PART4/code/D/PyBulletTime/src/simulation.py", line 257, in ComputeViewFromLink
        rgbim = Image.fromarray(imgs[2])
                ^^^^^^^^^^^^^^^^^^^^^^^^
      File "/data/ackley/PART4/code/D/PyBulletTime/.venv/lib/python3.12/site-packages/PIL/Image.py", line 3304, in fromarray
        arr = obj.__array_interface__
              ^^^^^^^^^^^^^^^^^^^^^^^
    AttributeError: 'tuple' object has no attribute '__array_interface__'
    make: *** [Makefile:12: debug] Error 1

so that's saying that PIL has broken backward
compatibility in 3.12 or something?[630:

Sat Oct 19 03:17:37 2024 Ugh and after fixing that
in several places, with a new helper method and
all, I figure out that I have significant version
skew with the simulation.py I was working on for
the last two weeks (such as I was) so I ended up
doing a messy hand merge of the versions ugh.

But modren Beevee now appears to be running? Let's
see if we can get BVBrain talking to it.

:630]

:629]
:628]

:627]
:626]

:625]
:624]

:623]

:622]

:621]
[631:

Mon Oct 21 09:47:13 2024 OK so I went and make
LocalSpaceRect2D.ulam (and its ..State as well)
and now I'm debugging it. Current issue is
mSymmetry is not getting set up reliably away from
the root, for reasons so far undetermined.

Looking at LocalSpaceRect2DState.observe(..) at
the moment.. and it seems plausible so far, using
LHops but not relying on maxlhops, which is what
we lose in going from diamond to square..

Continuing to trace through.[632:

Mon Oct 21 09:55:49 2024 Buuut we have lhops now
returning max(x,y) - on the L-inf metric - rather
than sum(x,y) so does that even specify a reliable
upstream for us? We're only examining ngbs that
differ in one coord, so..

I think we need to have lhops remain sum(x,y) and
instead don't depend on maxlhops.. At least let's
try heading in that direction.

:632]

:631]
[633:

Sat Oct 26 06:16:00 2024 OK, so trying to get
dendritic trees going and have made some progress
but now have run into a thinko: How do we stop the
axon from 'joining' another axon on its own chain?
How do we tell the difference?

Smells like another flag to say whether this chain
has terminated successfully yet, and we won't join
onto an unterminated axon.

What's our bit budget looking like?[634:

Sat Oct 26 06:18:56 2024
 - AxonHead and AxonTail has 22b free each
 - AxonMid has 18b

So maybe it's another Bool that propagates
toward the tail, and originates when
searchForAnchor() finds something or doesn't. 
[635:

Sun Oct 27 00:21:58 2024 OK, so 'dendritic tree
formation' is now vaguely plausible. We need to
start sending some signals and see the resulting
chaos. 
[636:

Sun Oct 27 01:20:04 2024 OK so now signals are
moving from SDBG (tail) to MDBG (head), but

 (1) They're backing up at MDBG instead of getting
     consumed
 (2) Dendritic branches appear to be willing to
     branch off of an AxonTail? Rather than only
     an AxonMid?
[637:

Sun Oct 27 01:32:38 2024 OK fixed those, but

 (1) AxonHeads at branch points don't propagate
     signals onto the target branch.
[638:

Sun Oct 27 05:08:23 2024 OK now we have fairly
plausible motorbound signaling through a dendritic
tree. We made a 24 min spontaneous-in-T-shirt demo
[639:

Sun Oct 27 13:21:56 2024 Which we are now
uploading, "fully raw and uncut", to T2Demos..
[640:

Mon Oct 28 01:18:07 2024 Where it now has 14
views, making it #1 in its publication lifetime
compared to the last ten videos on the T2Demos
channel. [641:

Mon Oct 28 01:19:18 2024 We need to think about
ways to keep loops from forming during growth and
regrowth. 

:641]
:640]

:639]

:638]

:637]

:636]
:635]
:634]

:633]
[642:

Mon Oct 28 14:35:24 2024 What if we just have a
single XTimer (for H->T direction anyway) that we
count() on every Axon event everywhere. And that
we reset when we see a real tap, not just a
branch.

And we min that value into the xtimers down in the
axon tree, keeping non-root nodes from triggering
so long as the thing gets reset often enough by
'real tap views' from upstream..[643:

Mon Oct 28 14:51:12 2024 Except wait a minute: If
we make a tapless-loop and min against our
upstream, will the net count around the loop
increase at all reliably?[644:

Mon Oct 28 15:38:45 2024 So it seems like a timer
doesn't really help? If we get looped we can keep
minning the timer indefinitely.

What if we only care if the timer is zero? If the
upstream timer is zero with min our timer with 1?

And the same problem with sending signals. We have
to consume the signals somewhere or they'll just
keep looping, and if we do consume them how do we
know they'll get to the tips of the tree in time
to keep them from dying?

It all seems to be equivalent to counting branch
length, so that loops will always count to
infinity and poop out. But then our longest axon
length is limited to that length as well.

[645:

Mon Oct 28 16:34:54 2024 Fuck it let's count axon
length. [646:

Mon Oct 28 16:35:48 2024 Could we count branchings
instead of axons? That would give us a lot more
coverage.. Can't have a loop without a branch? At
least not without trying pretty damn
deliberately..

Let's try that.

:646]

:645]

:644]

:643]


:642]
[647:

Wed Oct 30 04:18:24 2024

Pathfinder / path recording

 grip
 count
 result

 square grid

:647]
[648:

Thu Oct 31 12:23:37 2024

MINIMAL PATH RECORDING
FOR A LAME DOWN PAYMENT

TODO
 - make a grey cross counter
 - make a segment memory:
   = prev grip#
   = this grip#
   = left clicks / right clicks
   = next grip#
 - can we store all that? with say six or seven
   bits per click?
   = ah but can we store it in an axon or similar?
   [649:
   Thu Oct 31 12:37:42 2024 Not in an axonmid, no.
   :649]

:648]
[650:

Thu Oct 31 12:38:42 2024 What about some kind of
demo where Beevee does some random sequence of
grips, and then tries to duplicate it?

But grip changing is mostly bottom-up at the
moment, right?

:650]
[651:

Thu Oct 31 12:40:30 2024 Well let's try just to
make a click counter, and get that hooked up
somewhere, and see how it goes.

:651]
