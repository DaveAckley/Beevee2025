#!/usr/bin/env python3
import os
import sys

from math import prod

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

import datetime

import hashlib

import tomlikey as tomli

class Config:
    def __init__(self, name, path):
        self.name = name
        self.path = path
        self.reset()

    def reset(self):
        self.hash = None
        self.rawfile = None
        self.rawfileCS = None
        
    def __str__(self):
        return f"C:{self.name}"

    def __repr__(self):
        return f"[C:{self.name}:{self.path}]"

    def load(self):
        # Read whole file for storage
        with open(self.path,"rb") as file:
            self.rawfile = file.read()
        eprint("CONFIGLEN =",len(self.rawfile),"FOR",self.path)

        # Save its hash for checking
        h = hashlib.sha256()
        h.update(self.rawfile)
        self.rawfileCS = h.digest()
        
        # Parse it using dtomlib
        self.hash = tomli.loads(self.rawfile.decode())

    def getFileBytes(self):
        return self.rawfile

    def getFileChecksum(self):
        return self.rawfileCS

    def getRequiredSection(self,name):
        assert name in self.hash, f"Unknown section {name}"
        return self.hash[name]
        
    def getOptionalSection(self,name):
        return self.hash.get(name, None)

    def getInitializedSection(self,name,value):
        have = self.getOptionalSection(name)
        if not have:
            self.hash[name] = value
        return self.getRequiredSection(name)

from pprint import pprint

def xbname(name):
    return "XBInfo_"+name

def addc(*arg):
    return tuple(sum(t) for t in zip(*arg))

def mulc(*arg):
    return tuple(prod(t) for t in zip(*arg))

def smulc(scalar,tup):
    return [ scalar * t for t in tup ]

def saddc(scalar,tup):
    return [ scalar + t for t in tup ]


class Main:
    def __init__(self,name,brainFile,spineFile):
        self.name = name
        eprint("__main__",self.name)
        self.configPath = self.findConfigOrDie(brainFile)
        self.brainCfg = self.loadConfig(self.configPath)
        self.spineCfg = self.loadConfig(spineFile)

    def mapDir(self,dir):
        if dir == 'N':
            return [0,-1]
        if dir == 'S':
            return [0,1]
        if dir == 'E':
            return [1,0]
        if dir == 'W':
            return [-1,0]
        raise ValueError('illegal dir',dir)

    def oppDir(self,dir):
        if dir == 'N':
            return 'S'
        if dir == 'S':
            return 'N'
        if dir == 'E':
            return 'W'
        if dir == 'W':
            return 'E'
        raise ValueError('illegal dir',dir)

    def growDir(self,dir):      # Direction dir taps are laid out
        if dir == 'N':
            return 'E'
        if dir == 'S':
            return 'W'
        if dir == 'E':
            return 'S'
        if dir == 'W':
            return 'N'
        raise ValueError('illegal dir',dir)
    
    def generate(self):
        print(f"//AUTOGENERATED ON {datetime.datetime.now()} DO NOT EDIT")
        xb = self.brainCfg.getRequiredSection("xbar")
        print('''
@Concrete
transient BeeveeBIM : BrainInfoMap {
  constant ClassId cXBClassIds[] = {''')
        count = 0
        for k,v in xb.items():
            v['number'] = count
            count = count + 1
            print(f"    {xbname(k)}.classidof,")
        print('''    0 // unused, illegal
  }; // cXBClassIds''')

        print('''
  constant ClassId cTAPClassIds[] = {''')
        taps = self.taps
        count = 0
        for t in ('sensor','motor','hidden'):
            for k,v in taps[t].items():
                c = count
                count = count + 1
                v['number'] = c
                name = v.get('name',"")
                print(f"    {k}.classidof,  //< {c} {t} {name}")
        print('''  }; // cTAPClassIds''')

        print('''
  constant String cTAPNames[] = {''')
        taps = self.taps
        count = 0
        for t in ('sensor','motor','hidden'):
            for k,v in taps[t].items():
                c = count
                count = count + 1
                v['number'] = c
                name = v.get('name',"")
                print(f"    \"{k}\",  //< {c} {t} {name}")
        print('''  }; // cTAPNames''')

        print('''
  //// BrainInfoMap API
  @Override
  Unsigned getXBCount() { return cXBClassIds.lengthof - 1u; }
  @Override
  Unsigned getContainingXBIndex(C2D absc) {''')
        for k,v in xb.items():
            print(f'''\
    {{ C2D s({xbname(k)}.cXBI_SIZ), p({xbname(k)}.cXBI_POS);
       if (s.contains(absc-p)) return {v['number']}u; }}\
''')
        print('''\
    return Unsigned.maxof;
  }''')
        print('''
  @Override
  XBInfo & getXBInfo(Unsigned idx, XBInfoBuffer xbib) {
    Unsigned cnt = getXBCount();
    if (idx >= cnt) fail(__FILE__,__LINE__);
    ClassId cid = cXBClassIds[idx];
    ClassUtils cu;
    if (!cu.isBase(cid, XBInfo.classidof)) 
      fail(__FILE__,__LINE__);
    XBInfo & ret = (XBInfo&) xbib.recast(cid,true);
    return ret;
  }

  @Override
  virtual ClassId getTAPClassIdFromTapIdx(Unsigned tapidx) {
    return cTAPClassIds[tapidx]; // or fail if tapidx >= cTAPClassIds.lengthof
  }

  @Override
  virtual Unsigned getTAPCount() {
    return cTAPClassIds.lengthof;
  }

  @Override
  virtual Unsigned getTapIdxFromClassId(ClassId cid) {
    for (Unsigned i = 0u; i < cTAPClassIds.lengthof; ++i) {
      if (cid == cTAPClassIds[i])
        return i;
    }
    return Unsigned.maxof;
  }

  @Override
  virtual String getTAPNameFromTapIdx(Unsigned tapidx) {
    String ret;  // null by default
    if (tapidx < cTAPNames.lengthof) ret = cTAPNames[tapidx];
    return ret;
  }

''')
        print('}')

        for k,v in xb.items():
            self.analyzeXBar(k,v)

        for k,v in xb.items():
            self.generateXBar(k,v)

    def findCorner(self,ind,outd):
        if ind == 'N' and outd == 'E' or ind == 'E' and outd == 'N':
            return 'NE'
        if ind == 'N' and outd == 'W' or ind == 'W' and outd == 'N':
            return 'NW'
        if ind == 'S' and outd == 'W' or ind == 'W' and outd == 'S':
            return 'SW'
        if ind == 'S' and outd == 'E' or ind == 'E' and outd == 'S':
            return 'SE'
        raise ValueError('Bad corner',ind,outd)

    def analyzeXBar(self,name,props):
        xbpos = props['pos']
        # Derive size
        inlen = len(props['inputs'])
        outlen = len(props['outputs'])

        ind = props['indir']
        outd = props['outdir']

        props['origin'] = self.findCorner(ind,outd);

        props['inoff'] = self.mapDir(self.growDir(ind))
        props['outoff'] = self.mapDir(self.growDir(outd))

        if ind == 'N' or ind == 'S':
            w = inlen
            h = outlen
        else:                   # 'E' or 'W'
            h = inlen
            w = outlen
        props['size'] = [w+2,h+2]

        count = 0
        for intap in props['inputs']:
            count = count+1
            tappos = addc(smulc(count,props['inoff']),xbpos)
            self.generateTAP('in',intap,name,count,tappos)

        count = 0
        for outtap in props['outputs']:
            count = count+1
            tappos = addc(smulc(count,props['outoff']),xbpos)
            self.generateTAP('out',outtap,name,count,tappos)

    def generateTAP(self,iodir,tapname,xbname,num,tappos):
        taps = self.brainCfg.getInitializedSection("tap",{})
        if not tapname in taps:
            taps[tapname] = {}
        tap = taps[tapname]
        if not 'uses' in tap:
            tap['uses'] = {}
        uses = tap['uses']
        if not tapname in uses:
            uses[xbname] = [iodir,tappos,num]
        print(f'// {tap} TAP {iodir} {tapname} #{num} in {xbname} at {tappos}')

    def getRelBox(self,side,size):
        if side == 'W':
            return ((0,1),(1,size[1]-1))
        if side == 'N':
            return ((1,0),(size[0]-1,1))
        if side == 'S':
            return ((1,size[1]-1),(size[0]-1,size[1]))
        if side == 'E':
            return ((size[0]-1,1),(size[0],size[1]-1))
        raise ValueError('Bad side',side)
        
    def generateFeedDirCode(self,props):
        print(f'''// generateFeedDirCode({props})
  @Override
  virtual Bool getXBInfoFeedDir(C2D relc, AxialDir & feedad, Bool & isinput) {{\
''')
        for side,isinput in (('indir','true'), ('outdir','false')):
            dir = props[side]
            relbox = self.getRelBox(dir,props['size'])
            print(f'''\
    mD&&pR("GFDCD{side}10")&&pR(relc);
    if (relc.x >= {relbox[0][0]} && relc.y >= {relbox[0][1]} &&
        relc.x <  {relbox[1][0]} && relc.y < {relbox[1][1]}) {{
      feedad = c{dir};
      isinput = {isinput};
      return true;
    }}
    mD&&pR("GFDCD{side}11");
''')
        print('''\
    return false;
  }
''')

    def generateAxonTargetCode(self,props):
        print(f'''// generateAxonTargetCode({props})
  @Override
  virtual TapIdx getXBInfoAxonTarget(TapIdx tapidx) {{
    BeeveeBIM bim;
    ClassId fromid = bim.getTAPClassIdFromTapIdx(tapidx);\
''')
        for tfrom,tto in props.get('axons',[]):
            print(f'''\
    if (fromid == {tfrom}.classidof) return (TapIdx) bim.getTapIdxFromClassId({tto}.classidof);\
''')
        print('''\
    return cTAPIDX_NONE;
  }
''')

    def generateTAPCheckCode(self,var,svar,side,vec,props):
        relbox = self.getRelBox(props[side],props['size'])
        print(f'// generateTAPCheckCode({side},{vec},{props}) {relbox}')
        print(f'''\
    mD&&pR("GXBIT{side}10")&&pR({var});
    if ({svar} &&
        {var}.x >= {relbox[0][0]} && {var}.y >= {relbox[0][1]} &&
        {var}.x <  {relbox[1][0]} && {var}.y < {relbox[1][1]}) {{
      C2D diff((C2D.Coord) ({var}.x-{relbox[0][0]}),(C2D.Coord) ({var}.y-{relbox[0][1]}));
      Unsigned idx = diff.length();\
      mD&&pR("GXBIT{side}11")&&pR(diff)&&pR(idx);
''')
        if vec == 'inputs':
            avar = 'cIN_TAPS'
        elif vec == 'outputs':
            avar = 'cOUT_TAPS'
        else:
            raise ValueError('bad vec',vec)
        print(f'''\
      return {avar}[idx];            
    }}''')
    
    def generateXBar(self,name,props):
        n = xbname(name)
        print(f'''
//NAME {n} IS {props}
@Concrete
transient {n} : XBInfo {{\
''')
        print(f'''\
  constant ClassId cIN_TAPS[] = {{\
''')
        for intap in props['inputs']:
            print(f'    {intap}.classidof,')
        print(f'''\
  }}; // cIN_TAPS''')

        print(f'''
  constant ClassId cOUT_TAPS[] = {{\
''')
        for outtap in props['outputs']:
            print(f'    {outtap}.classidof,')
        print(f'''\
  }}; // cOUT_TAPS''')

        print(f'''
  constant PocketDir cXBI_ORIGIN = cQUAD_{props['origin']};
  constant AxialDir cXBI_IN_DIR = c{props['indir']};
  constant AxialDir cXBI_OUT_DIR = c{props['outdir']};

  constant C2D cXBI_POS = {{ .x = {props['pos'][0]}, .y = {props['pos'][1]} }};
  constant C2D cXBI_SIZ = {{ .x = {props['size'][0]}, .y = {props['size'][1]} }};
  //// XBInfo API
  @Override virtual String getXBInfoName() {{ return "{name}"; }}
  @Override virtual C2D getXBInfoPosition() {{ return cXBI_POS; }}
  @Override virtual C2D getXBInfoSize() {{ return cXBI_SIZ; }}
  @Override virtual PocketDir getXBInfoOrigin() {{ return cXBI_ORIGIN; }}
  @Override virtual AxialDir getXBInfoTAPEdge(Bool sensor) {{ 
    return sensor ? cXBI_IN_DIR : cXBI_OUT_DIR; 
  }}

''')
        self.generateFeedDirCode(props)
        self.generateAxonTargetCode(props)
        
        print(f'''
  @Override
  virtual ClassId getXBInfoTAP(C2D relc, Bool sensor) {{\
''')
        self.generateTAPCheckCode('relc','sensor','indir','inputs',props)
        self.generateTAPCheckCode('relc','!sensor','outdir','outputs',props)
        print('''\
    return 0u;
  }

''')
        print(f'}} // {n}')

    def generateOutput(self):
        cfg = self.brainCfg
        csect = cfg.getRequiredSection("Config") # ensure exists?
        self.generate()

    def findConfigOrDie(self,optPath):
        paths = []
        if optPath != None:
            paths.append(optPath)
        # e = os.environ
        # ekey ='BEEVEESOURCESPATH'
        # if ekey in e:           # First try environmental variable
        #     paths.append(e[ekey])
        # paths.append('../code/BVBrain.cfg') # Then 'std loc'
        # paths.append('./BVBrain.cfg')       # Last ditch
        for p in paths:
            (exists,path) = self.expandPath(p)
            if exists:
                eprint(f"Found config file {path}")
                return path
        self.die(f"Config file not found in {paths}")

    def expandPath(self,path):
        epath = os.path.expanduser(path)
        if os.path.exists(epath):
            return (True,epath)
        return (False,None)

    def die(self,message):
        eprint(f"Error: {message}")
        exit(2)

    def loadConfig(self,path):
        if os.path.isfile(path):
            ret = Config("Cfg",path)
        else:
            self.die(f"Can't load {path}")
        ret.load()
        return ret

    def analyzeSpineTAPs(self):
        scfg = self.spineCfg
        terms = scfg.getRequiredSection('term')
        self.taps = dict(sensor= {}, motor= {}, hidden= {})
        for k,v in terms.items():
            if v.get('disabled',0) == 1:
                continue
            eprint(f'STUFFJDKDKD {k}:{v}')
            t = v['type']
            if t == 'sensor' or t == 'motor':
                self.taps[t][k] = {'name': v.get('name'), 'doc': v.get('doc',"")}
        eprint(f'zongdK {self.taps}')

    def mergeBrainTAPs(self):
        xb = self.brainCfg.getRequiredSection("xbar")
        for k,v in xb.items():  # per xb
            for l,type,otype in (('inputs','sensor','sensor'), ('outputs','motor','hidden')):
                for tap in v[l]:
                    if self.taps[type].get(tap) == None:
                        self.taps[otype][tap] = {'name': tap, 'doc': f'xbar.{k} {l}'}
        eprint(f'MERGBNONIC {self.taps}')

if __name__ == '__main__':

    import sys
    argc = len(sys.argv)
    if argc <= 2 or argc > 3:
        sys.exit("Usage: " + __file__ + " BRAINCONFIGFILE SPINECONFIGFILE")
    brainFile = sys.argv[1]
    spineFile = sys.argv[2]

    print("// RUNNING",__file__ ,"\n// ON",brainFile,"\n// AND",spineFile,"---")
    mr = Main("ZONGProd",brainFile,spineFile)
    mr.analyzeSpineTAPs()
    mr.mergeBrainTAPs()
    mr.generateOutput()
